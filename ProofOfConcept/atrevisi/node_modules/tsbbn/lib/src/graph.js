"use strict";

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, "__esModule", { value: true });

var Variable = function Variable(id, name, _values) {
    _classCallCheck(this, Variable);

    this.id = id;
    this.name = name;
    this._values = _values;
    this.values = [].concat(_toConsumableArray(_values));
};

exports.Variable = Variable;

var BGraph = function () {
    function BGraph() {
        _classCallCheck(this, BGraph);

        this.nodes = new Map();
        this.edges = new Map();
    }

    _createClass(BGraph, [{
        key: "getNeighbors",
        value: function getNeighbors(id) {
            var _this = this;

            var keys = Array.from(this.edges.keys());
            var neighbors1 = keys.filter(function (key) {
                return _this.edges.get(key).has(id);
            });
            var neighbors2 = this.edges.has(id) ? Array.from(this.edges.get(id).values()) : [];
            var neighbors = neighbors1.concat(neighbors2);
            return new Set(neighbors);
        }
    }, {
        key: "getNode",
        value: function getNode(id) {
            return this.nodes.get(id);
        }
    }, {
        key: "getNodes",
        value: function getNodes() {
            var _this2 = this;

            return Array.from(this.nodes.keys()).map(function (id) {
                return _this2.nodes.get(id);
            });
        }
    }, {
        key: "getEdges",
        value: function getEdges() {
            var _this3 = this;

            var keys = Array.from(this.edges.keys());
            var stream = keys.map(function (lhsId) {
                var edges = Array.from(_this3.edges.get(lhsId)).map(function (rhsId) {
                    var edgeType = EdgeType.UNDIRECTED;
                    var leftId = lhsId;
                    var rightId = rhsId;
                    if (!_this3.edges.get(rhsId).has(lhsId)) {
                        edgeType = EdgeType.DIRECTED;
                    } else {
                        leftId = Math.min(lhsId, rhsId);
                        rightId = leftId === lhsId ? rhsId : lhsId;
                    }
                    return new BEdge(new BNode(leftId), new BNode(rightId), edgeType);
                });
                return edges;
            });
            return this.removeDuplicates(this.flatten(stream));
        }
    }, {
        key: "addNode",
        value: function addNode(node) {
            if (!this.nodes.has(node.id)) {
                this.nodes.set(node.id, node);
            }
            if (!this.edges.has(node.id)) {
                this.edges.set(node.id, new Set());
            }
            return this;
        }
    }, {
        key: "addEdge",
        value: function addEdge(edge) {
            var lhs = edge.lhs;
            var rhs = edge.rhs;
            this.addNode(lhs);
            this.addNode(rhs);
            if (this.shouldAdd(edge)) {
                var left = lhs.id;
                var right = rhs.id;
                if (EdgeType.UNDIRECTED === edge.type) {
                    this.edges.get(left).add(right);
                    this.edges.get(right).add(left);
                } else {
                    this.edges.get(left).add(right);
                }
            }
            return this;
        }
    }, {
        key: "edgeExists",
        value: function edgeExists(id1, id2) {
            if (this.edges.has(id1) && this.edges.get(id1).has(id2)) {
                return true;
            }
            if (this.edges.has(id2) && this.edges.get(id2).has(id1)) {
                return true;
            }
            return false;
        }
    }, {
        key: "removeNode",
        value: function removeNode(id) {
            this.nodes.delete(id);
            this.edges.delete(id);
            this.edges.forEach(function (v, k) {
                return v.delete(id);
            });
        }
    }, {
        key: "shouldAdd",
        value: function shouldAdd(edge) {
            var lhs = edge.lhs;
            var rhs = edge.rhs;
            if (lhs.id === rhs.id) {
                return false;
            }
            if (!this.edges.get(lhs.id).has(rhs.id)) {
                if (!this.edges.get(rhs.id).has(lhs.id)) {
                    return true;
                }
            }
            return false;
        }
    }, {
        key: "flatten",
        value: function flatten(edges) {
            var list = [];
            for (var i = 0; i < edges.length; i++) {
                for (var j = 0; j < edges[i].length; j++) {
                    list.push(edges[i][j]);
                }
            }
            return list;
        }
    }, {
        key: "removeDuplicates",
        value: function removeDuplicates(edges) {
            var map = new Map();
            var arr = [];
            edges.forEach(function (e) {
                var key = e.toString();
                if (!map.has(key)) {
                    map.set(key, e);
                    arr.push(e);
                }
            });
            return arr;
        }
    }]);

    return BGraph;
}();

exports.BGraph = BGraph;

var BNode = function () {
    function BNode(id) {
        _classCallCheck(this, BNode);

        this.id = id;
        this.metadata = new Map();
    }

    _createClass(BNode, [{
        key: "addMetadata",
        value: function addMetadata(key, val) {
            this.metadata.set(key, val);
            return this;
        }
    }]);

    return BNode;
}();

exports.BNode = BNode;

var BbnNode = function (_BNode) {
    _inherits(BbnNode, _BNode);

    function BbnNode(variable) {
        var probs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

        _classCallCheck(this, BbnNode);

        var _this4 = _possibleConstructorReturn(this, (BbnNode.__proto__ || Object.getPrototypeOf(BbnNode)).call(this, variable.id));

        _this4.variable = variable;
        _this4.probs = probs;
        return _this4;
    }

    _createClass(BbnNode, [{
        key: "getWeight",
        value: function getWeight() {
            return this.variable.values.length;
        }
    }, {
        key: "toString",
        value: function toString() {
            var s = this.variable.name + ' {';
            s += this.variable.values.join(',');
            s += '}';
            return s;
        }
    }]);

    return BbnNode;
}(BNode);

exports.BbnNode = BbnNode;

var Clique = function (_BNode2) {
    _inherits(Clique, _BNode2);

    function Clique(nodes) {
        _classCallCheck(this, Clique);

        var _this5 = _possibleConstructorReturn(this, (Clique.__proto__ || Object.getPrototypeOf(Clique)).call(this, IdUtil.hashOfArr(nodes.map(function (n) {
            return '' + n.id;
        }))));

        _this5.nodes = nodes;
        _this5._marked = false;
        return _this5;
    }

    _createClass(Clique, [{
        key: "isMarked",
        value: function isMarked() {
            return this._marked;
        }
    }, {
        key: "mark",
        value: function mark() {
            this._marked = true;
        }
    }, {
        key: "unmark",
        value: function unmark() {
            this._marked = false;
        }
    }, {
        key: "nodesMinus",
        value: function nodesMinus(nodes) {
            var ids = this.nodes.map(function (n) {
                return n.id;
            });
            return nodes.filter(function (n) {
                return ids.indexOf(n.id) === -1;
            });
        }
    }, {
        key: "isSuperset",
        value: function isSuperset(that) {
            var s1 = this.nodes.map(function (n) {
                return n.id;
            });
            var s2 = new Set(that.nodes.map(function (n) {
                return n.id;
            }));
            var s3 = new Set(s1.filter(function (id) {
                return s2.has(id);
            }));
            if (s2.size === s3.size) {
                // console.log(this.toString() + ' is superset of ' + that.toString());
                return true;
            }
            // console.log(this.toString() + ' is NOT superset of ' + that.toString());
            return false;
        }
    }, {
        key: "getWeight",
        value: function getWeight() {
            var weight = 1;
            this.nodes.forEach(function (n) {
                weight = weight * n.getWeight();
            });
            return weight;
        }
    }, {
        key: "contains",
        value: function contains(id) {
            var result = this.nodes.find(function (n) {
                return n.id === id;
            });
            if (result) {
                return true;
            }
            return false;
        }
    }, {
        key: "getSepSet",
        value: function getSepSet(that) {
            return new SepSet(this, that);
        }
    }, {
        key: "toString",
        value: function toString() {
            return '(' + this.nodes.map(function (n) {
                return n.variable.name;
            }).sort(function (a, b) {
                return CompareUtil.strCompare(a, b);
            }).join('-') + ')';
        }
    }]);

    return Clique;
}(BNode);

exports.Clique = Clique;

var SepSet = function (_Clique) {
    _inherits(SepSet, _Clique);

    function SepSet(left, right) {
        _classCallCheck(this, SepSet);

        var _this6 = _possibleConstructorReturn(this, (SepSet.__proto__ || Object.getPrototypeOf(SepSet)).call(this, []));

        _this6.left = left;
        _this6.right = right;
        var set2 = new Set(left.nodes.map(function (n) {
            return n.id;
        }));
        var set1 = new Set(right.nodes.filter(function (n) {
            return set2.has(n.id);
        }).map(function (n) {
            return n.id;
        }));
        _this6.nodes = left.nodes.filter(function (n) {
            return set1.has(n.id);
        });
        _this6.id = IdUtil.hashOfArr(_this6.nodes.map(function (n) {
            return '' + n.id;
        }));
        return _this6;
    }

    _createClass(SepSet, [{
        key: "isEmpty",
        value: function isEmpty() {
            return this.nodes.length == 0 ? true : false;
        }
    }, {
        key: "getCost",
        value: function getCost() {
            return this.left.getWeight() + this.right.getWeight();
        }
    }, {
        key: "getMass",
        value: function getMass() {
            return this.nodes.length;
        }
    }, {
        key: "toString",
        value: function toString() {
            return '[' + this.nodes.map(function (n) {
                return n.variable.name;
            }).sort(function (a, b) {
                return CompareUtil.strCompare(a, b);
            }).join('-') + ']';
        }
    }]);

    return SepSet;
}(Clique);

exports.SepSet = SepSet;

var BEdge = function () {
    function BEdge(lhs, rhs) {
        var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EdgeType.UNDIRECTED;

        _classCallCheck(this, BEdge);

        this.lhs = lhs;
        this.rhs = rhs;
        this.type = type;
    }

    _createClass(BEdge, [{
        key: "toString",
        value: function toString() {
            var arrow = EdgeType.UNDIRECTED === this.type ? '--' : '->';
            var left = this.lhs.id;
            var right = this.rhs.id;
            if (EdgeType.UNDIRECTED === this.type) {
                left = Math.min(this.lhs.id, this.rhs.id);
                right = this.lhs.id === left ? this.rhs.id : this.lhs.id;
            }
            return left + arrow + right;
        }
    }]);

    return BEdge;
}();

exports.BEdge = BEdge;

var JtEdge = function (_BEdge) {
    _inherits(JtEdge, _BEdge);

    function JtEdge(sepSet) {
        _classCallCheck(this, JtEdge);

        var _this7 = _possibleConstructorReturn(this, (JtEdge.__proto__ || Object.getPrototypeOf(JtEdge)).call(this, sepSet.left, sepSet.right, EdgeType.UNDIRECTED));

        _this7.sepSet = sepSet;
        return _this7;
    }

    _createClass(JtEdge, [{
        key: "toString",
        value: function toString() {
            return this.sepSet.left.toString() + '--' + this.sepSet.toString() + '--' + this.sepSet.right.toString();
        }
    }]);

    return JtEdge;
}(BEdge);

exports.JtEdge = JtEdge;
var EdgeType;
(function (EdgeType) {
    EdgeType[EdgeType["UNDIRECTED"] = 1] = "UNDIRECTED";
    EdgeType[EdgeType["DIRECTED"] = 2] = "DIRECTED";
})(EdgeType = exports.EdgeType || (exports.EdgeType = {}));

var Dag = function (_BGraph) {
    _inherits(Dag, _BGraph);

    function Dag() {
        _classCallCheck(this, Dag);

        return _possibleConstructorReturn(this, (Dag.__proto__ || Object.getPrototypeOf(Dag)).call(this));
    }

    _createClass(Dag, [{
        key: "getParents",
        value: function getParents(id) {
            var _this9 = this;

            var keys = Array.from(this.edges.keys());
            var parents = keys.filter(function (key) {
                return _this9.edges.get(key).has(id);
            });
            return new Set(parents);
        }
    }, {
        key: "getChildren",
        value: function getChildren(id) {
            return this.edges.get(id);
        }
    }, {
        key: "edgeExists",
        value: function edgeExists(id1, id2) {
            if (this.edges.has(id1) && this.edges.get(id1).has(id2)) {
                return true;
            }
            return false;
        }
    }, {
        key: "shouldAdd",
        value: function shouldAdd(edge) {
            var parent = edge.lhs;
            var child = edge.rhs;
            if (parent.id === child.id) {
                return false;
            }
            if (!this.edges.get(parent.id).has(child.id)) {
                if (!this.edges.get(child.id).has(parent.id)) {
                    if (!new DagPathDetector(this, child.id, parent.id).exists()) {
                        return true;
                    }
                }
            }
            return false;
        }
    }]);

    return Dag;
}(BGraph);

exports.Dag = Dag;

var Bbn = function (_Dag) {
    _inherits(Bbn, _Dag);

    function Bbn() {
        _classCallCheck(this, Bbn);

        return _possibleConstructorReturn(this, (Bbn.__proto__ || Object.getPrototypeOf(Bbn)).apply(this, arguments));
    }

    _createClass(Bbn, [{
        key: "shouldAdd",
        value: function shouldAdd(edge) {
            if (!(edge.lhs instanceof BbnNode) || !(edge.rhs instanceof BbnNode)) {
                return false;
            }
            return _get(Bbn.prototype.__proto__ || Object.getPrototypeOf(Bbn.prototype), "shouldAdd", this).call(this, edge);
        }
    }]);

    return Bbn;
}(Dag);

exports.Bbn = Bbn;

var DagPathDetector = function () {
    function DagPathDetector(graph, start, stop) {
        _classCallCheck(this, DagPathDetector);

        this.seen = new Set();
        this.graph = graph;
        this.start = start;
        this.stop = stop;
    }

    _createClass(DagPathDetector, [{
        key: "exists",
        value: function exists() {
            if (this.start === this.stop) {
                return true;
            }
            return this.find(this.start);
        }
    }, {
        key: "find",
        value: function find(id) {
            var children = this.graph.getChildren(id);
            if (children.has(this.stop)) {
                return true;
            } else {
                this.seen.add(id);
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var child = _step.value;

                        if (!this.seen.has(child) && this.find(child)) {
                            return true;
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
            return false;
        }
    }]);

    return DagPathDetector;
}();

var Pdag = function (_BGraph2) {
    _inherits(Pdag, _BGraph2);

    function Pdag() {
        _classCallCheck(this, Pdag);

        return _possibleConstructorReturn(this, (Pdag.__proto__ || Object.getPrototypeOf(Pdag)).apply(this, arguments));
    }

    _createClass(Pdag, [{
        key: "getParents",
        value: function getParents(id) {
            var _this12 = this;

            var parents = Array.from(this.edges.keys()).filter(function (key) {
                return _this12.edges.get(key).has(id) && !_this12.edges.get(id).has(key);
            });
            return new Set(parents);
        }
    }, {
        key: "getOutNodes",
        value: function getOutNodes(id) {
            var parents = this.getParents(id);
            var subset = Array.from(this.getNeighbors(id)).filter(function (item) {
                return !parents.has(item);
            });
            return new Set(subset);
        }
    }, {
        key: "shouldAdd",
        value: function shouldAdd(edge) {
            var parent = edge.lhs;
            var child = edge.rhs;
            if (parent.id === child.id) {
                return false;
            }
            if (!this.edges.get(parent.id).has(child.id)) {
                if (!this.edges.get(child.id).has(parent.id)) {
                    if (!new PdagPathDetector(this, child.id, parent.id).exists()) {
                        return true;
                    }
                }
            }
            return false;
        }
    }]);

    return Pdag;
}(BGraph);

exports.Pdag = Pdag;

var PdagPathDetector = function () {
    function PdagPathDetector(graph, start, stop) {
        _classCallCheck(this, PdagPathDetector);

        this.seen = new Set();
        this.graph = graph;
        this.start = start;
        this.stop = stop;
    }

    _createClass(PdagPathDetector, [{
        key: "exists",
        value: function exists() {
            if (this.start === this.stop) {
                return true;
            }
            return this.find(this.start);
        }
    }, {
        key: "find",
        value: function find(id) {
            var outNodes = this.graph.getOutNodes(id);
            if (outNodes.has(this.stop)) {
                return true;
            } else {
                this.seen.add(id);
                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = undefined;

                try {
                    for (var _iterator2 = outNodes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                        var outNode = _step2.value;

                        if (!this.seen.has(outNode)) {
                            if (this.find(outNode)) {
                                return true;
                            }
                        }
                    }
                } catch (err) {
                    _didIteratorError2 = true;
                    _iteratorError2 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion2 && _iterator2.return) {
                            _iterator2.return();
                        }
                    } finally {
                        if (_didIteratorError2) {
                            throw _iteratorError2;
                        }
                    }
                }
            }
            return false;
        }
    }]);

    return PdagPathDetector;
}();

var Ug = function (_BGraph3) {
    _inherits(Ug, _BGraph3);

    function Ug() {
        _classCallCheck(this, Ug);

        return _possibleConstructorReturn(this, (Ug.__proto__ || Object.getPrototypeOf(Ug)).call(this));
    }

    return Ug;
}(BGraph);

exports.Ug = Ug;

var JoinTree = function (_Ug) {
    _inherits(JoinTree, _Ug);

    function JoinTree() {
        _classCallCheck(this, JoinTree);

        var _this14 = _possibleConstructorReturn(this, (JoinTree.__proto__ || Object.getPrototypeOf(JoinTree)).call(this));

        _this14.potentials = new Map();
        _this14.evidences = new Map();
        return _this14;
    }

    _createClass(JoinTree, [{
        key: "getBbnPotential",
        value: function getBbnPotential(node) {
            var clique = node.metadata.get('parent.clique');
            return PotentialUtil.normalize(PotentialUtil.marginalizeFor(this, clique, [node]));
        }
    }, {
        key: "unmarkCliques",
        value: function unmarkCliques() {
            this.getCliques().forEach(function (clique) {
                return clique.unmark();
            });
        }
    }, {
        key: "getBbnNodes",
        value: function getBbnNodes() {
            var nodes = new Map();
            this.getCliques().forEach(function (clique) {
                clique.nodes.forEach(function (node) {
                    return nodes.set(node.id, node);
                });
            });
            var bbnNodes = [];
            nodes.forEach(function (v, k) {
                return bbnNodes.push(v);
            });
            return bbnNodes;
        }
    }, {
        key: "getBbnNode",
        value: function getBbnNode(id) {
            var bbnNodes = this.getBbnNodes();
            for (var i = 0; i < bbnNodes.length; i++) {
                if (id === bbnNodes[i].id) {
                    return bbnNodes[i];
                }
            }
            return new BbnNode(new Variable(-1, '_dummy_', new Set()));
        }
    }, {
        key: "getBbnNodeByName",
        value: function getBbnNodeByName(name) {
            return this.getBbnNodes().filter(function (n) {
                return n.variable.name === name;
            })[0];
        }
    }, {
        key: "findCliquesWithNodeAndParents",
        value: function findCliquesWithNodeAndParents(id) {
            var _this15 = this;

            return this.getCliques().filter(function (clique) {
                if (!clique.contains(id)) {
                    return false;
                }
                var bbnNode = _this15.getBbnNode(id);
                if (bbnNode.metadata.has('parents')) {
                    var parents = bbnNode.metadata.get('parents');
                    for (var i = 0; i < parents.length; i++) {
                        var parent = parents[i];
                        if (!clique.contains(parent.id)) {
                            return false;
                        }
                    }
                }
                return true;
            });
        }
    }, {
        key: "addPotential",
        value: function addPotential(clique, potential) {
            this.potentials.set(clique.id, potential);
            return this;
        }
    }, {
        key: "getCliques",
        value: function getCliques() {
            return this.getNodes().filter(function (n) {
                return !(n instanceof SepSet);
            }).map(function (n) {
                return n;
            });
        }
    }, {
        key: "getSepSets",
        value: function getSepSets() {
            return this.getNodes().filter(function (n) {
                return n instanceof SepSet;
            }).map(function (n) {
                return n;
            });
        }
    }, {
        key: "addEdge",
        value: function addEdge(edge) {
            if (!(edge instanceof JtEdge)) {
                return this;
            }
            var jtEdge = edge;
            var sepSet = jtEdge.sepSet;
            var lhs = jtEdge.lhs;
            var rhs = jtEdge.rhs;
            if (this.shouldAdd(edge)) {
                this.addNode(sepSet);
                this.addNode(lhs);
                this.addNode(rhs);
                this.edges.get(lhs.id).add(sepSet.id);
                this.edges.get(sepSet.id).add(lhs.id);
                this.edges.get(rhs.id).add(sepSet.id);
                this.edges.get(sepSet.id).add(rhs.id);
            }
            return this;
        }
    }, {
        key: "setListener",
        value: function setListener(listener) {
            this.listener = listener;
        }
    }, {
        key: "getEvidence",
        value: function getEvidence(node, value) {
            if (!this.evidences.has(node.id)) {
                this.evidences.set(node.id, new Map());
            }
            if (!this.evidences.get(node.id).has(value)) {
                var potentialEntry = new PotentialEntry();
                potentialEntry.add(node.id, value);
                potentialEntry.value = 1.0;
                var potential = new Potential();
                potential.addEntry(potentialEntry);
                this.evidences.get(node.id).set(value, potential);
            }
            return this.evidences.get(node.id).get(value);
        }
    }, {
        key: "unobserve",
        value: function unobserve(nodes) {
            var _this16 = this;

            var evidences = nodes.map(function (n) {
                return _this16.getUnobservedEvidence(n);
            });
            this.updateEvidences(evidences);
            return this;
        }
    }, {
        key: "unobserveAll",
        value: function unobserveAll() {
            this.unobserve(this.getBbnNodes());
            return this;
        }
    }, {
        key: "updateEvidences",
        value: function updateEvidences(evidences) {
            var _this17 = this;

            evidences.forEach(function (e) {
                return e.validate();
            });
            var change = this.getChangeType(evidences);
            evidences.forEach(function (evidence) {
                var node = evidence.node;
                var potentials = _this17.evidences.get(node.id);
                evidence.values.forEach(function (v, k) {
                    var potential = potentials.get(k);
                    potential.entries[0].value = v;
                });
            });
            this.notifyListener(change);
            return this;
        }
    }, {
        key: "setObservation",
        value: function setObservation(evidence) {
            // only deal with observation types in this method
            if (EvidenceType.OBSERVATION !== evidence.type) {
                // console.log('evidence not observation type returning');
                return this;
            }
            // check to see if previous evidence was also observation
            // evidence that is observation type always has only one value that is 1
            var potentials = this.evidences.get(evidence.node.id);
            var pvalues = Array.from(potentials.keys()).filter(function (v) {
                var potential = potentials.get(v);
                var entry = potential.entries[0];
                var p = entry.value;
                if (p === 1.0) {
                    return true;
                }
                return false;
            });
            var cvalues = Array.from(evidence.values.keys()).filter(function (v) {
                return 1.0 === evidence.values.get(v);
            });
            if (1 === pvalues.length) {
                // previous evidence was of type observation
                // both current and previous evidences are observation type
                // console.log('both previous and current evidences are of type observation');
                var lastValue = pvalues[0];
                var currValue = cvalues[0];
                if (lastValue === currValue) {
                    // if the last value is equal to the current value, unobserve it
                    // console.log(lastValue + ' equals ' + currValue + ' so will unobserve');
                    this.unobserve([evidence.node]);
                } else {
                    // console.log(lastValue + ' NOT equals ' + currValue + ' so will update evidence');
                    this.updateEvidences([evidence]);
                }
            } else {
                // console.log('number previous values === 1 was ' + pvalues.length + ' so will update evidence');
                this.updateEvidences([evidence]);
            }
            return this;
        }
    }, {
        key: "shouldAdd",
        value: function shouldAdd(edge) {
            var jtEdge = edge;
            var sepSet = jtEdge.sepSet;
            var lhs = jtEdge.lhs;
            var rhs = jtEdge.rhs;
            if (lhs.id === rhs.id) {
                // console.log('false: ' + jtEdge.toString());
                return false;
            }
            if (!new JoinTreePathDetector(this, lhs.id, rhs.id).exists()) {
                // console.log('true: ' +  jtEdge.toString());
                return true;
            }
            // console.log('false: ' + jtEdge.toString());
            return false;
        }
    }, {
        key: "getChangeType",
        value: function getChangeType(evidences) {
            var _this18 = this;

            var changes = evidences.map(function (evidence) {
                var node = evidence.node;
                var potentials = _this18.evidences.get(node.id);
                var change = evidence.compare(potentials);
                return change;
            });
            var count = changes.filter(function (c) {
                return ChangeType.RETRACTION === c;
            }).length;
            if (count > 0) {
                return ChangeType.RETRACTION;
            }
            count = changes.filter(function (c) {
                return ChangeType.UPDATE === c;
            }).length;
            if (count > 0) {
                return ChangeType.UPDATE;
            }
            return ChangeType.NONE;
        }
    }, {
        key: "getUnobservedEvidence",
        value: function getUnobservedEvidence(node) {
            var evidence = new Evidence(node, EvidenceType.UNOBSERVE);
            node.variable.values.forEach(function (v) {
                return evidence.addValue(v, 1.0);
            });
            return evidence;
        }
    }, {
        key: "notifyListener",
        value: function notifyListener(change) {
            if (this.listener) {
                if (ChangeType.RETRACTION === change) {
                    this.listener.evidenceRetracted(this);
                } else if (ChangeType.UPDATE === change) {
                    this.listener.evidenceUpdated(this);
                }
            }
        }
    }]);

    return JoinTree;
}(Ug);

exports.JoinTree = JoinTree;

var JoinTreePathDetector = function () {
    function JoinTreePathDetector(graph, start, stop) {
        _classCallCheck(this, JoinTreePathDetector);

        this.seen = new Set();
        this.graph = graph;
        this.start = start;
        this.stop = stop;
    }

    _createClass(JoinTreePathDetector, [{
        key: "exists",
        value: function exists() {
            if (this.start === this.stop) {
                return true;
            }
            return this.find(this.start);
        }
    }, {
        key: "find",
        value: function find(id) {
            var neighbors = this.graph.getNeighbors(id);
            if (neighbors.has(this.stop)) {
                return true;
            } else {
                this.seen.add(id);
                var _iteratorNormalCompletion3 = true;
                var _didIteratorError3 = false;
                var _iteratorError3 = undefined;

                try {
                    for (var _iterator3 = neighbors[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                        var neighbor = _step3.value;

                        if (!this.seen.has(neighbor)) {
                            if (this.find(neighbor)) {
                                return true;
                            }
                        }
                    }
                } catch (err) {
                    _didIteratorError3 = true;
                    _iteratorError3 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion3 && _iterator3.return) {
                            _iterator3.return();
                        }
                    } finally {
                        if (_didIteratorError3) {
                            throw _iteratorError3;
                        }
                    }
                }
            }
            return false;
        }
    }]);

    return JoinTreePathDetector;
}();

var EvidenceType;
(function (EvidenceType) {
    EvidenceType[EvidenceType["VIRTUAL"] = 1] = "VIRTUAL";
    EvidenceType[EvidenceType["FINDING"] = 2] = "FINDING";
    EvidenceType[EvidenceType["OBSERVATION"] = 3] = "OBSERVATION";
    EvidenceType[EvidenceType["UNOBSERVE"] = 4] = "UNOBSERVE";
})(EvidenceType = exports.EvidenceType || (exports.EvidenceType = {}));
var ChangeType;
(function (ChangeType) {
    ChangeType[ChangeType["NONE"] = 1] = "NONE";
    ChangeType[ChangeType["UPDATE"] = 2] = "UPDATE";
    ChangeType[ChangeType["RETRACTION"] = 3] = "RETRACTION";
})(ChangeType = exports.ChangeType || (exports.ChangeType = {}));

var EvidenceBuilder = function () {
    function EvidenceBuilder() {
        _classCallCheck(this, EvidenceBuilder);

        this.values = new Map();
        this.type = EvidenceType.OBSERVATION;
    }

    _createClass(EvidenceBuilder, [{
        key: "withNode",
        value: function withNode(node) {
            this.node = node;
            return this;
        }
    }, {
        key: "withType",
        value: function withType(type) {
            this.type = type;
            return this;
        }
    }, {
        key: "withEvidence",
        value: function withEvidence(val, likelihood) {
            this.values.set(val, likelihood);
            return this;
        }
    }, {
        key: "build",
        value: function build() {
            var evidence = new Evidence(this.node, this.type);
            this.values.forEach(function (v, k) {
                return evidence.values.set(k, v);
            });
            return evidence;
        }
    }]);

    return EvidenceBuilder;
}();

exports.EvidenceBuilder = EvidenceBuilder;

var Evidence = function () {
    function Evidence(node, type) {
        _classCallCheck(this, Evidence);

        this.node = node;
        this.type = type;
        this.values = new Map();
    }

    _createClass(Evidence, [{
        key: "addValue",
        value: function addValue(value, likelihood) {
            this.values.set(value, likelihood);
            return this;
        }
    }, {
        key: "compare",
        value: function compare(potentials) {
            var that = this.convert(potentials);
            var unobserveThat = this.isUnobserved(that);
            var unobserveThis = this.isUnobserved(this.values);
            if (unobserveThat && unobserveThis) {
                return ChangeType.NONE;
            }
            var observeThat = this.isObserved(that);
            var observeThis = this.isObserved(this.values);
            if (observeThat && observeThis) {
                var s1 = this.getObservedValue(that);
                var s2 = this.getObservedValue(this.values);
                if (s1 === s2) {
                    return ChangeType.NONE;
                } else {
                    return ChangeType.RETRACTION;
                }
            }
            return ChangeType.RETRACTION;
        }
    }, {
        key: "validate",
        value: function validate() {
            var _this19 = this;

            this.node.variable.values.forEach(function (value) {
                if (!_this19.values.has(value)) {
                    _this19.values.set(value, 0.0);
                }
            });
            if (EvidenceType.VIRTUAL === this.type) {
                var sum = this.node.variable.values.map(function (value) {
                    return _this19.values.get(value);
                }).reduce(function (a, b) {
                    return a + b;
                });
                this.node.variable.values.forEach(function (value) {
                    var d = _this19.values.get(value) / sum;
                    _this19.values.set(value, d);
                });
            } else if (EvidenceType.FINDING === this.type) {
                this.node.variable.values.forEach(function (value) {
                    var d = _this19.values.get(value) > 0.0 ? 1.0 : 0.0;
                    _this19.values.set(value, d);
                });
                var count = this.node.variable.values.map(function (value) {
                    return _this19.values.get(value);
                }).reduce(function (a, b) {
                    return a + b;
                });
                if (0 === count) {
                    this.node.variable.values.forEach(function (value) {
                        return _this19.values.set(value, 1.0);
                    });
                }
            } else if (EvidenceType.OBSERVATION === this.type) {
                var keys = Array.from(this.values.keys()).sort(function (a, b) {
                    return -1 * CompareUtil.intCompare(_this19.values.get(a), _this19.values.get(b));
                });
                var key = keys[0];
                this.node.variable.values.forEach(function (value) {
                    if (key === value) {
                        _this19.values.set(value, 1.0);
                    } else {
                        _this19.values.set(value, 0.0);
                    }
                });
            } else if (EvidenceType.UNOBSERVE === this.type) {
                this.node.variable.values.forEach(function (value) {
                    return _this19.values.set(value, 1.0);
                });
            }
        }
    }, {
        key: "convert",
        value: function convert(map) {
            var m = new Map();
            map.forEach(function (v, k) {
                var likelihood = v.entries[0].value;
                m.set(k, likelihood);
            });
            return m;
        }
    }, {
        key: "isUnobserved",
        value: function isUnobserved(values) {
            var counts = 0;
            values.forEach(function (v, k) {
                return counts += v;
            });
            return counts === values.size;
        }
    }, {
        key: "isObserved",
        value: function isObserved(values) {
            var countOne = 0;
            var countZero = 0;
            values.forEach(function (v, k) {
                if (1.0 === v) {
                    countOne++;
                } else if (0.0 === v) {
                    countZero++;
                }
            });
            return 1 === countOne && values.size - 1 === countZero;
        }
    }, {
        key: "getObservedValue",
        value: function getObservedValue(values) {
            var strs = Array.from(values.keys()).filter(function (k) {
                return 1.0 === values.get(k);
            });
            return strs[0];
        }
    }]);

    return Evidence;
}();

exports.Evidence = Evidence;

var Potential = function () {
    function Potential() {
        _classCallCheck(this, Potential);

        this.entries = [];
    }

    _createClass(Potential, [{
        key: "addEntry",
        value: function addEntry(entry) {
            this.entries.push(entry);
        }
    }, {
        key: "getMatchingEntries",
        value: function getMatchingEntries(entry) {
            return this.entries.filter(function (e) {
                return e.matches(entry);
            });
        }
    }, {
        key: "toString",
        value: function toString() {
            var s = '';
            this.entries.forEach(function (entry) {
                return s += entry.toString() + '\n';
            });
            return s.substr(0, s.length - 1);
        }
    }]);

    return Potential;
}();

exports.Potential = Potential;

var PotentialEntry = function () {
    function PotentialEntry() {
        _classCallCheck(this, PotentialEntry);

        this.entries = new Map();
        this.value = 1.0;
    }

    _createClass(PotentialEntry, [{
        key: "add",
        value: function add(id, value) {
            if (!this.entries.has(id)) {
                this.entries.set(id, value);
            }
            return this;
        }
    }, {
        key: "matches",
        value: function matches(that) {
            var _iteratorNormalCompletion4 = true;
            var _didIteratorError4 = false;
            var _iteratorError4 = undefined;

            try {
                for (var _iterator4 = that.entries.keys()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                    var key = _step4.value;

                    if (!this.entries.has(key) || !(this.entries.get(key) === that.entries.get(key))) {
                        return false;
                    }
                }
            } catch (err) {
                _didIteratorError4 = true;
                _iteratorError4 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion4 && _iterator4.return) {
                        _iterator4.return();
                    }
                } finally {
                    if (_didIteratorError4) {
                        throw _iteratorError4;
                    }
                }
            }

            return true;
        }
    }, {
        key: "toString",
        value: function toString() {
            var s = '';
            this.entries.forEach(function (v, k) {
                s += k + '=' + v + ',';
            });
            s += this.value;
            return s;
        }
    }, {
        key: "duplicate",
        value: function duplicate() {
            var entry = new PotentialEntry();
            this.entries.forEach(function (v, k) {
                return entry.add(k, v);
            });
            entry.value = this.value;
            return entry;
        }
    }]);

    return PotentialEntry;
}();

exports.PotentialEntry = PotentialEntry;

var IdUtil = function () {
    function IdUtil() {
        _classCallCheck(this, IdUtil);
    }

    _createClass(IdUtil, null, [{
        key: "hashOfStr",
        value: function hashOfStr(s) {
            var hash = 0;
            if (s.length === 0) {
                return hash;
            }
            for (var i = 0, len = s.length; i < len; i++) {
                var chr = s.charCodeAt(i);
                hash = (hash << 5) - hash + chr;
                hash |= 0; // Convert to 32bit integer
            }
            return hash;
        }
    }, {
        key: "hashOfArr",
        value: function hashOfArr(arr) {
            return this.hashOfStr(arr.sort().join('-'));
        }
    }]);

    return IdUtil;
}();

exports.IdUtil = IdUtil;

var PotentialUtil = function () {
    function PotentialUtil() {
        _classCallCheck(this, PotentialUtil);
    }

    _createClass(PotentialUtil, null, [{
        key: "passSingleMessage",
        value: function passSingleMessage(jointree, x, s, y) {
            // console.log('passing message ' + x.toString() + ' -- ' + s.toString() + ' -- ' + y.toString());
            var oldSepSetPotential = jointree.potentials.get(s.id);
            var yPotential = jointree.potentials.get(y.id);
            var newSepSetPotential = this.marginalizeFor(jointree, x, s.nodes);
            jointree.addPotential(s, newSepSetPotential);
            this.multiply(yPotential, this.divide(newSepSetPotential, oldSepSetPotential));
        }
    }, {
        key: "marginalizeFor",
        value: function marginalizeFor(joinTree, clique, nodes) {
            var potential = this.getPotentialFromNodes(nodes);
            var cliquePotential = joinTree.potentials.get(clique.id);
            potential.entries.forEach(function (entry) {
                var matchedEntries = cliquePotential.getMatchingEntries(entry);
                var t = 0.0;
                matchedEntries.forEach(function (matchedEntry) {
                    return t += matchedEntry.value;
                });
                entry.value = t;
            });
            return potential;
        }
    }, {
        key: "normalize",
        value: function normalize(potential) {
            var sum = 0.0;
            potential.entries.forEach(function (entry) {
                sum += entry.value;
            });
            potential.entries.forEach(function (entry) {
                var d = entry.value / sum;
                entry.value = d;
            });
            return potential;
        }
    }, {
        key: "divide",
        value: function divide(numerator, denominator) {
            var _this20 = this;

            var potential = new Potential();
            numerator.entries.forEach(function (entry) {
                var entries = denominator.entries;
                if (entries.length > 0) {
                    var e = entries[0];
                    var d = _this20.isZero(entry.value) || _this20.isZero(e.value) ? 0.0 : entry.value / e.value;
                    var newEntry = entry.duplicate();
                    newEntry.value = d;
                    potential.addEntry(newEntry);
                }
            });
            return potential;
        }
    }, {
        key: "multiply",
        value: function multiply(bigger, smaller) {
            smaller.entries.forEach(function (entry) {
                var entries = bigger.getMatchingEntries(entry);
                entries.forEach(function (e) {
                    var d = e.value * entry.value;
                    e.value = d;
                });
            });
        }
    }, {
        key: "getPotential",
        value: function getPotential(node, parents) {
            var potential = this.getPotentialFromNodes(this.merge(node, parents));
            var total = potential.entries.length;
            for (var i = 0; i < total; i++) {
                var prob = node.probs[i];
                potential.entries[i].value = prob;
            }
            return potential;
        }
    }, {
        key: "getPotentialFromNodes",
        value: function getPotentialFromNodes(nodes) {
            var valueLists = nodes.map(function (n) {
                return n.variable.values;
            });
            var cartesian = this.getCartesianProduct(valueLists);
            var potential = new Potential();
            cartesian.forEach(function (values) {
                var entry = new PotentialEntry();
                for (var i = 0; i < nodes.length; i++) {
                    var value = values[i];
                    var id = nodes[i].id;
                    entry.add(id, value);
                }
                potential.addEntry(entry);
            });
            return potential;
        }
    }, {
        key: "isZero",
        value: function isZero(d) {
            return 0 === d;
        }
    }, {
        key: "getCartesianProduct",
        value: function getCartesianProduct(lists) {
            var results = [];
            if (lists.length === 0) {
                return results;
            } else {
                var first = lists[0];
                var tail = lists.slice(0).splice(1);
                var remaining = this.getCartesianProduct(tail);
                first.forEach(function (condition) {
                    if (remaining.length > 0) {
                        remaining.forEach(function (rlist) {
                            var result = [];
                            result.push(condition);
                            rlist.forEach(function (r) {
                                return result.push(r);
                            });
                            results.push(result);
                        });
                    } else {
                        var result = [];
                        result.push(condition);
                        results.push(result);
                    }
                });
            }
            return results;
        }
    }, {
        key: "merge",
        value: function merge(node, parents) {
            var nodes = [];
            parents.forEach(function (n) {
                return nodes.push(n);
            });
            nodes.push(node);
            return nodes;
        }
    }]);

    return PotentialUtil;
}();

exports.PotentialUtil = PotentialUtil;

var BbnUtil = function () {
    function BbnUtil() {
        _classCallCheck(this, BbnUtil);
    }

    _createClass(BbnUtil, null, [{
        key: "getHuangGraph",
        value: function getHuangGraph() {
            var a = new BbnNode(new Variable(0, 'a', new Set(['on', 'off'])), [0.5, 0.5]);
            var b = new BbnNode(new Variable(1, 'b', new Set(['on', 'off'])), [0.5, 0.5, 0.4, 0.6]);
            var c = new BbnNode(new Variable(2, 'c', new Set(['on', 'off'])), [0.7, 0.3, 0.2, 0.8]);
            var d = new BbnNode(new Variable(3, 'd', new Set(['on', 'off'])), [0.9, 0.1, 0.5, 0.5]);
            var e = new BbnNode(new Variable(4, 'e', new Set(['on', 'off'])), [0.3, 0.7, 0.6, 0.4]);
            var f = new BbnNode(new Variable(5, 'f', new Set(['on', 'off'])), [0.01, 0.99, 0.01, 0.99, 0.01, 0.99, 0.99, 0.01]);
            var g = new BbnNode(new Variable(6, 'g', new Set(['on', 'off'])), [0.8, 0.2, 0.1, 0.9]);
            var h = new BbnNode(new Variable(7, 'h', new Set(['on', 'off'])), [0.05, 0.95, 0.95, 0.05, 0.95, 0.05, 0.95, 0.05]);
            var bbn = new Bbn().addNode(a).addNode(b).addNode(c).addNode(d).addNode(e).addNode(f).addNode(g).addNode(h).addEdge(new BEdge(a, b, EdgeType.DIRECTED)).addEdge(new BEdge(a, c, EdgeType.DIRECTED)).addEdge(new BEdge(b, d, EdgeType.DIRECTED)).addEdge(new BEdge(c, e, EdgeType.DIRECTED)).addEdge(new BEdge(d, f, EdgeType.DIRECTED)).addEdge(new BEdge(e, f, EdgeType.DIRECTED)).addEdge(new BEdge(c, g, EdgeType.DIRECTED)).addEdge(new BEdge(e, h, EdgeType.DIRECTED)).addEdge(new BEdge(g, h, EdgeType.DIRECTED));
            return bbn;
        }
    }]);

    return BbnUtil;
}();

exports.BbnUtil = BbnUtil;

var CompareUtil = function () {
    function CompareUtil() {
        _classCallCheck(this, CompareUtil);
    }

    _createClass(CompareUtil, null, [{
        key: "intCompare",
        value: function intCompare(x, y) {
            return x < y ? -1 : x === y ? 0 : 1;
        }
    }, {
        key: "strCompare",
        value: function strCompare(x, y) {
            return x.localeCompare(y);
        }
    }]);

    return CompareUtil;
}();

exports.CompareUtil = CompareUtil;

//# sourceMappingURL=graph.js.map
//# sourceMappingURL=graph.js.map
