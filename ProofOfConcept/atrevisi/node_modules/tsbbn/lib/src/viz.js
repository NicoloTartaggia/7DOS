"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, "__esModule", { value: true });
var d3 = require("d3");
var OUT_LEFT = 1,
    OUT_TOP = 2,
    OUT_RIGHT = 4,
    OUT_BOTTOM = 8;
var MAX_NODE_NAME_LENGTH = 15;
var MAX_VALUE_LENGTH = 5;
var MAX_PCT_VALUE = 6;
var DEFAULT_PADDING = "\xA0";

var VGraph = function () {
    function VGraph() {
        _classCallCheck(this, VGraph);

        this.nodes = new Map();
        this.edges = new Map();
    }

    _createClass(VGraph, [{
        key: "getNodes",
        value: function getNodes() {
            return Array.from(this.nodes.values());
        }
    }, {
        key: "getEdges",
        value: function getEdges() {
            return Array.from(this.edges.values());
        }
    }, {
        key: "addNode",
        value: function addNode(node) {
            this.nodes.set(node.id, node);
            return this;
        }
    }, {
        key: "addEdge",
        value: function addEdge(edge) {
            this.edges.set(edge.getId(), edge);
            return this;
        }
    }, {
        key: "getNode",
        value: function getNode(id) {
            return this.nodes.get(id);
        }
    }, {
        key: "getPath",
        value: function getPath(id1, id2) {
            return this.getNode(id1).getPath(this.getNode(id2));
        }
    }]);

    return VGraph;
}();

exports.VGraph = VGraph;

var VEdge = function () {
    function VEdge(parent, child) {
        _classCallCheck(this, VEdge);

        this.parent = parent;
        this.child = child;
        this.points = [];
    }

    _createClass(VEdge, [{
        key: "getId",
        value: function getId() {
            return Util.hashOfStr(this.toString());
        }
    }, {
        key: "toString",
        value: function toString() {
            return this.parent.label + '->' + this.child.label;
        }
    }]);

    return VEdge;
}();

exports.VEdge = VEdge;

var VNode = function () {
    function VNode(id, label, values, probs) {
        _classCallCheck(this, VNode);

        this.id = id;
        this.label = label;
        this.values = values;
        this.probs = probs;
        this.width = 150;
        this.probs = this.normalizeProbs(this.probs);
        this.height = values.length * 15 + 20;
        this.point = new VPoint(Math.random(), Math.random());
    }

    _createClass(VNode, [{
        key: "updatePoint",
        value: function updatePoint(point) {
            this.point.x = point.x;
            this.point.y = point.y;
        }
    }, {
        key: "getRefId",
        value: function getRefId() {
            return this.label;
        }
    }, {
        key: "getTranslation",
        value: function getTranslation() {
            return 'translate(' + this.point.x + ',' + this.point.y + ')';
        }
    }, {
        key: "getMid",
        value: function getMid() {
            var dx = this.width / 2.0 + this.point.x;
            var dy = this.height / 2.0 + this.point.y;
            return new VPoint(dx, dy);
        }
    }, {
        key: "normalizeProbs",
        value: function normalizeProbs(probs) {
            var sum = probs.reduce(function (a, b) {
                return a + b;
            });
            return probs.map(function (p) {
                return p / sum;
            });
        }
    }, {
        key: "getPath",
        value: function getPath(that) {
            var theta = that.point.getTheta(this.point);
            var p1 = this.getPoint(theta);
            var p2 = that.getPoint(theta + Math.PI);
            var error = p1.error || p2.error ? true : false;
            var path = new VPath(p1, p2);
            path.error = error;
            return path;
        }
    }, {
        key: "toString",
        value: function toString() {
            return this.id + '|' + this.label + '|' + this.values.join(',') + '|' + this.probs.join(',') + '|' + this.point.toString();
        }
    }, {
        key: "getPoint",
        value: function getPoint(theta) {
            var c = this.getMid();
            var cx = c.x;
            var cy = c.y;
            var w = this.width / 2.0;
            var h = this.height / 2.0;
            var d = this.getDistance(new VPoint(cx, cy), new VPoint(cx + w, cy + h));
            var x = cx + d * Math.cos(theta);
            var y = cy + d * Math.sin(theta);
            var ocode = this.getOutCode(new VPoint(x, y));
            var px = 0;
            var py = 0;
            var error = false;
            switch (ocode) {
                case OUT_TOP:
                    px = cx - h * ((x - cx) / (y - cy));
                    py = cy - h;
                    break;
                case OUT_LEFT:
                    px = cx - w;
                    py = cy - w * ((y - cy) / (x - cx));
                    break;
                case OUT_BOTTOM:
                    px = cx + h * ((x - cx) / (y - cy));
                    py = cy + h;
                    break;
                case OUT_RIGHT:
                    px = cx + w;
                    py = cy + w * ((y - cy) / (x - cx));
                    break;
                default:
                    error = true;
            }
            var p = new VPoint(px, py);
            p.error = error;
            return p;
        }
    }, {
        key: "getDistance",
        value: function getDistance(p1, p2) {
            var x = p1.x - p2.x;
            var y = p1.y - p2.y;
            var d = Math.sqrt(x * x + y * y);
            return d;
        }
    }, {
        key: "getOutCode",
        value: function getOutCode(point) {
            var out = 0;
            if (this.width <= 0) {
                out |= OUT_LEFT | OUT_RIGHT;
            } else if (point.x < this.point.x) {
                out |= OUT_LEFT;
            } else if (point.x > this.point.x + this.width) {
                out |= OUT_RIGHT;
            }
            if (this.height <= 0) {
                out |= OUT_TOP | OUT_BOTTOM;
            } else if (point.y < this.point.y) {
                out |= OUT_TOP;
            } else if (point.y > this.point.y + this.height) {
                out |= OUT_BOTTOM;
            }
            return out;
        }
    }]);

    return VNode;
}();

exports.VNode = VNode;

var VPoint = function () {
    function VPoint(x, y) {
        _classCallCheck(this, VPoint);

        this.x = x;
        this.y = y;
        this.error = false;
    }

    _createClass(VPoint, [{
        key: "toString",
        value: function toString() {
            return '(' + this.x + ',' + this.y + ')';
        }
    }, {
        key: "getTheta",
        value: function getTheta(that) {
            return Math.atan2(this.y - that.y, this.x - that.x);
        }
    }]);

    return VPoint;
}();

exports.VPoint = VPoint;

var VPath = function () {
    function VPath(p1, p2) {
        _classCallCheck(this, VPath);

        this.p1 = p1;
        this.p2 = p2;
        this.error = false;
    }

    _createClass(VPath, [{
        key: "toString",
        value: function toString() {
            return this.p1.toString() + ' to ' + this.p2.toString();
        }
    }]);

    return VPath;
}();

exports.VPath = VPath;

var Util = function () {
    function Util() {
        _classCallCheck(this, Util);
    }

    _createClass(Util, null, [{
        key: "hashOfStr",
        value: function hashOfStr(s) {
            var hash = 0;
            if (s.length === 0) {
                return hash;
            }
            for (var i = 0, len = s.length; i < len; i++) {
                var chr = s.charCodeAt(i);
                hash = (hash << 5) - hash + chr;
                hash |= 0; // Convert to 32bit integer
            }
            return hash;
        }
    }, {
        key: "hashOfArr",
        value: function hashOfArr(arr) {
            return this.hashOfStr(arr.sort().join('-'));
        }
    }]);

    return Util;
}();

exports.Util = Util;

var NoOpInferenceEngine = function () {
    function NoOpInferenceEngine(graph) {
        _classCallCheck(this, NoOpInferenceEngine);

        this.graph = graph;
    }

    _createClass(NoOpInferenceEngine, [{
        key: "getGraph",
        value: function getGraph() {
            return this.graph;
        }
    }, {
        key: "updateEvidence",
        value: function updateEvidence(id, value) {}
    }, {
        key: "getProbs",
        value: function getProbs(id) {
            return this.graph.getNode(id).probs;
        }
    }]);

    return NoOpInferenceEngine;
}();

exports.NoOpInferenceEngine = NoOpInferenceEngine;

var RenderOptions = function RenderOptions(id, width, height) {
    _classCallCheck(this, RenderOptions);

    this.id = id;
    this.width = width;
    this.height = height;
};

exports.RenderOptions = RenderOptions;

var GraphRenderer = function () {
    function GraphRenderer(engine, options) {
        _classCallCheck(this, GraphRenderer);

        this.engine = engine;
        this.options = options;
        this.graph = this.engine.getGraph();
    }

    _createClass(GraphRenderer, [{
        key: "draw",
        value: function draw() {
            this.initSvg();
            this.layoutGraph();
            this.drawEdges();
            this.drawNodes();
        }
    }, {
        key: "initSvg",
        value: function initSvg() {
            d3.select(this.options.id).attr({
                width: this.options.width,
                height: this.options.height
            }).append('defs').append('marker').attr({
                id: 'arrow',
                markerWidth: 10,
                markerHeight: 10,
                refX: 5,
                refY: 3,
                orient: 'auto',
                markerUnits: 'strokeWidth'
            }).append('path').attr({
                d: 'M0,0 L0,6, L5,3 z',
                fill: '#f00',
                class: 'edge-head'
            });
        }
    }, {
        key: "getDagreGraph",
        value: function getDagreGraph() {
            var g = new dagre.graphlib.Graph();
            g.setGraph({});
            g.setDefaultEdgeLabel(function () {
                return {};
            });
            this.graph.getNodes().forEach(function (n) {
                g.setNode(n.getRefId(), {
                    label: n.getRefId(),
                    width: n.width,
                    height: n.height
                });
            });
            this.graph.getEdges().forEach(function (e) {
                g.setEdge(e.parent.getRefId(), e.child.getRefId());
            });
            return g;
        }
    }, {
        key: "layoutGraph",
        value: function layoutGraph() {
            var g = this.getDagreGraph();
            dagre.layout(g);
            this.graph.getNodes().forEach(function (n) {
                var dagreNode = g.node(n.getRefId());
                if (dagreNode) {
                    n.updatePoint(new VPoint(dagreNode.x, dagreNode.y));
                }
            });
            this.graph.getEdges().forEach(function (e) {
                var dagreEdge = g.edge({ v: e.parent.getRefId(), w: e.child.getRefId() });
                if (dagreEdge) {
                    e.points = Array.from(dagreEdge.points).map(function (point) {
                        var p = point;
                        return new VPoint(p.x, p.y);
                    });
                }
            });
        }
    }, {
        key: "drawEdges",
        value: function drawEdges() {
            var graph = this.graph;
            var edges = d3.select(this.options.id).selectAll('line').data(graph.getEdges()).enter().append('line').each(function (d) {
                var path = graph.getPath(d.parent.id, d.child.id);
                d3.select(this).attr({
                    'data-parent': d.parent.getRefId(),
                    'data-child': d.child.getRefId(),
                    x1: path.p1.x,
                    y1: path.p1.y,
                    x2: path.p2.x,
                    y2: path.p2.y,
                    style: 'stroke:rgb(255,0,0);stroke-width:2',
                    class: 'edge-line',
                    'marker-end': 'url(#arrow)'
                });
            });
        }
    }, {
        key: "drawNodes",
        value: function drawNodes() {
            var engine = this.engine;
            var graph = this.graph;
            var formatNodeName = this.formatNodeName;
            var formatPct = this.formatPct;
            var formatValue = this.formatValue;
            var leftPad = this.leftPad;
            var rightPad = this.rightPad;
            // set the node group
            var nodes = d3.select(this.options.id).selectAll('g').data(graph.getNodes()).enter().append('g').attr({
                id: function id(d) {
                    return d.getRefId();
                },
                transform: function transform(d) {
                    return d.getTranslation();
                },
                class: 'node-group'
            }).on('mousedown', function (d) {
                d3.selectAll('g.node-group').sort(function (a, b) {
                    if (a.id !== d.id) {
                        return -1;
                    } else {
                        return 1;
                    }
                });
            });
            // draw the node rectangle
            nodes.append('rect').attr({
                x: 0,
                y: 0,
                class: 'node-shape',
                style: 'stroke:#000000; fill:none;',
                width: function width(d) {
                    return d.width;
                },
                height: function height(d) {
                    return d.height;
                },
                'pointer-events': 'visible',
                'data-node': function dataNode(d) {
                    return d.getRefId();
                }
            });
            // draw the node's name/label
            nodes.append('text').attr({
                x: function x(d) {
                    return d.width / 2;
                },
                y: 15,
                fill: 'black',
                class: 'node-name',
                'font-family': 'monospace',
                'font-size': 15
            }).text(function (d) {
                return formatNodeName(d.label);
            }).style('text-anchor', 'middle');
            // draw the node's value labels
            nodes.each(function (d) {
                var _this = this;

                var y = 30;
                d.values.forEach(function (value) {
                    d3.select(_this).append('text').attr({
                        x: 2,
                        y: y,
                        class: 'node-value',
                        'font-family': 'monospace',
                        'data-node': function dataNode(d) {
                            return d.getRefId();
                        },
                        'data-value': function dataValue(d) {
                            return value;
                        }
                    }).on('click', function (e) {
                        var node = e;
                        var h = this;
                        var v = h.attributes['data-value'].value;
                        engine.updateEvidence(node.id, v);
                        graph.getNodes().forEach(function (node) {
                            return node.probs = engine.getProbs(node.id);
                        });
                        graph.getNodes().forEach(function (node) {
                            node.values.forEach(function (value, j) {
                                // update belief bars
                                var selector = 'rect[data-node="' + node.getRefId() + '"][data-value="' + value + '"]';
                                d3.select(selector).attr({ width: node.probs[j] * 100 });
                                // update probability texts
                                selector = 'text[data-node="' + node.getRefId() + '"][data-pvalue="' + value + '"]';
                                d3.select(selector).text(formatPct(node.probs[j], leftPad));
                            });
                        });
                    }).text(function (d) {
                        return formatValue(value, leftPad);
                    });
                    y += 15;
                });
            });
            // draw the node's percentage text
            nodes.each(function (d) {
                var _this2 = this;

                var y = 30;

                var _loop = function _loop(i) {
                    d3.select(_this2).append('text').attr({
                        x: 2 + d.width,
                        y: y,
                        'font-family': 'monospace',
                        class: 'node-pct',
                        'data-node': function dataNode(d) {
                            return d.getRefId();
                        },
                        'data-pvalue': function dataPvalue(d) {
                            return d.values[i];
                        }
                    }).text(function (d) {
                        return formatPct(d.probs[i], leftPad);
                    });
                    y += 15;
                };

                for (var i = 0; i < d.probs.length; i++) {
                    _loop(i);
                }
            });
            // draw the node's belief bars
            nodes.each(function (d) {
                var _this3 = this;

                var y = 20;
                d.probs.forEach(function (prob, index) {
                    d3.select(_this3).append('rect').attr({
                        x: 50,
                        y: y,
                        width: prob * 100,
                        height: 10,
                        class: 'node-bar',
                        'data-node': function dataNode(d) {
                            return d.getRefId();
                        },
                        'data-value': function dataValue(d) {
                            return d.values[index];
                        }
                    });
                    y += 15;
                });
            });
            // draw the node's interquartile lines
            nodes.each(function (d) {
                var y1 = 20;
                var y2 = d.height - 5;
                var width = d.width - 50;
                var xInc = width / 4.0;
                var x = 50 + xInc;
                for (var i = 0; i < 3; i++) {
                    d3.select(this).append('line').attr({
                        x1: x,
                        y1: y1,
                        x2: x,
                        y2: y2,
                        class: 'node-iqline',
                        'stroke-dasharray': '5, 1',
                        style: 'stroke:black; stroke-width:1px'
                    });
                    x += xInc;
                }
            });
            // set the dragging behavior
            var drag = d3.behavior.drag().origin(function (d, i) {
                var node = d;
                return node.point;
            }).on('dragstart', function (d, i) {
                var e = d3.event;
                e.sourceEvent.stopPropagation();
            }).on('drag', function (d, i) {
                var event = d3.event;
                var d3Event = d3.event;
                var mouseEvent = d3Event.sourceEvent;
                var node = d;
                node.point.x = event.x;
                node.point.y = event.y;
                var id = 'g#' + node.getRefId();
                d3.select(id).attr({
                    transform: node.getTranslation()
                });
                var arcs = 'line[data-parent=' + node.getRefId() + ']';
                d3.selectAll(arcs).each(function (d) {
                    var edge = d;
                    var path = graph.getPath(edge.parent.id, edge.child.id);
                    d3.select(this).attr({
                        x1: path.p1.x,
                        y1: path.p1.y,
                        x2: path.p2.x,
                        y2: path.p2.y
                    });
                });
                arcs = 'line[data-child=' + node.getRefId() + ']';
                d3.selectAll(arcs).each(function (d) {
                    var edge = d;
                    var path = graph.getPath(edge.parent.id, edge.child.id);
                    d3.select(this).attr({
                        x1: path.p1.x,
                        y1: path.p1.y,
                        x2: path.p2.x,
                        y2: path.p2.y
                    });
                });
            });
            nodes.call(drag);
        }
    }, {
        key: "leftPad",
        value: function leftPad(pad, threhold, str) {
            var ostr = str;
            if (ostr.length < threhold) {
                while (ostr.length < threhold) {
                    ostr = pad + ostr;
                }
                return ostr;
            }
            return ostr;
        }
    }, {
        key: "rightPad",
        value: function rightPad(pad, threhold, str) {
            var ostr = str;
            if (ostr.length < threhold) {
                while (ostr.length < threhold) {
                    ostr += pad;
                }
                return ostr;
            }
            return ostr;
        }
    }, {
        key: "formatNodeName",
        value: function formatNodeName(v) {
            return v.length > MAX_NODE_NAME_LENGTH ? v.substr(0, MAX_NODE_NAME_LENGTH) : v;
        }
    }, {
        key: "formatValue",
        value: function formatValue(v, padding) {
            var value = v.length > MAX_VALUE_LENGTH ? v.substr(0, MAX_VALUE_LENGTH) : v;
            return padding(DEFAULT_PADDING, MAX_VALUE_LENGTH, value);
        }
    }, {
        key: "formatPct",
        value: function formatPct(p, padding) {
            return padding(DEFAULT_PADDING, MAX_PCT_VALUE, (p * 100).toFixed(2));
        }
    }]);

    return GraphRenderer;
}();

exports.GraphRenderer = GraphRenderer;

//# sourceMappingURL=viz.js.map
//# sourceMappingURL=viz.js.map
