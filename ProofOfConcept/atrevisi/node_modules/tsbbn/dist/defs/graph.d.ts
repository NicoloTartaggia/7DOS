export declare class Variable {
    id: number;
    name: string;
    private _values;
    values: string[];
    constructor(id: number, name: string, _values: Set<string>);
}
export declare class BGraph {
    protected nodes: Map<number, BNode>;
    protected edges: Map<number, Set<number>>;
    constructor();
    getNeighbors(id: number): Set<number>;
    getNode(id: number): BNode;
    getNodes(): BNode[];
    getEdges(): BEdge[];
    addNode(node: BNode): BGraph;
    addEdge(edge: BEdge): BGraph;
    edgeExists(id1: number, id2: number): boolean;
    removeNode(id: number): void;
    protected shouldAdd(edge: BEdge): boolean;
    private flatten;
    private removeDuplicates;
}
export declare class BNode {
    id: number;
    metadata: Map<String, any>;
    constructor(id: number);
    addMetadata(key: String, val: any): BNode;
}
export declare class BbnNode extends BNode {
    variable: Variable;
    probs: number[];
    potential: Potential;
    constructor(variable: Variable, probs?: number[]);
    getWeight(): number;
    toString(): string;
}
export declare class Clique extends BNode {
    nodes: BbnNode[];
    private _marked;
    constructor(nodes: BbnNode[]);
    isMarked(): boolean;
    mark(): void;
    unmark(): void;
    nodesMinus(nodes: BbnNode[]): BbnNode[];
    isSuperset(that: Clique): boolean;
    getWeight(): number;
    contains(id: number): boolean;
    getSepSet(that: Clique): SepSet;
    toString(): string;
}
export declare class SepSet extends Clique {
    left: Clique;
    right: Clique;
    constructor(left: Clique, right: Clique);
    isEmpty(): boolean;
    getCost(): number;
    getMass(): number;
    toString(): string;
}
export declare class BEdge {
    lhs: BNode;
    rhs: BNode;
    type: EdgeType;
    constructor(lhs: BNode, rhs: BNode, type?: EdgeType);
    toString(): string;
}
export declare class JtEdge extends BEdge {
    sepSet: SepSet;
    constructor(sepSet: SepSet);
    toString(): string;
}
export declare enum EdgeType {
    UNDIRECTED = 1,
    DIRECTED = 2
}
export declare class Dag extends BGraph {
    constructor();
    getParents(id: number): Set<number>;
    getChildren(id: number): Set<number>;
    edgeExists(id1: number, id2: number): boolean;
    protected shouldAdd(edge: BEdge): boolean;
}
export declare class Bbn extends Dag {
    protected shouldAdd(edge: BEdge): boolean;
}
export declare class Pdag extends BGraph {
    getParents(id: number): Set<number>;
    getOutNodes(id: number): Set<number>;
    protected shouldAdd(edge: BEdge): boolean;
}
export declare class Ug extends BGraph {
    constructor();
}
export declare class JoinTree extends Ug {
    listener: JoinTreeListener;
    potentials: Map<number, Potential>;
    evidences: Map<number, Map<string, Potential>>;
    constructor();
    getBbnPotential(node: BbnNode): Potential;
    unmarkCliques(): void;
    getBbnNodes(): BbnNode[];
    getBbnNode(id: number): BbnNode;
    getBbnNodeByName(name: string): BbnNode;
    findCliquesWithNodeAndParents(id: number): Clique[];
    addPotential(clique: Clique, potential: Potential): JoinTree;
    getCliques(): Clique[];
    getSepSets(): SepSet[];
    addEdge(edge: BEdge): BGraph;
    setListener(listener: JoinTreeListener): void;
    getEvidence(node: BbnNode, value: string): Potential;
    unobserve(nodes: BbnNode[]): JoinTree;
    unobserveAll(): JoinTree;
    updateEvidences(evidences: Evidence[]): JoinTree;
    setObservation(evidence: Evidence): JoinTree;
    protected shouldAdd(edge: BEdge): boolean;
    private getChangeType;
    private getUnobservedEvidence;
    private notifyListener;
}
export interface JoinTreeListener {
    evidenceRetracted(jointree: JoinTree): void;
    evidenceUpdated(jointree: JoinTree): void;
}
export declare enum EvidenceType {
    VIRTUAL = 1,
    FINDING = 2,
    OBSERVATION = 3,
    UNOBSERVE = 4
}
export declare enum ChangeType {
    NONE = 1,
    UPDATE = 2,
    RETRACTION = 3
}
export declare class EvidenceBuilder {
    values: Map<string, number>;
    node: BbnNode;
    type: EvidenceType;
    withNode(node: BbnNode): EvidenceBuilder;
    withType(type: EvidenceType): EvidenceBuilder;
    withEvidence(val: string, likelihood: number): EvidenceBuilder;
    build(): Evidence;
}
export declare class Evidence {
    node: BbnNode;
    type: EvidenceType;
    values: Map<string, number>;
    constructor(node: BbnNode, type: EvidenceType);
    addValue(value: string, likelihood: number): Evidence;
    compare(potentials: Map<string, Potential>): ChangeType;
    validate(): void;
    private convert;
    private isUnobserved;
    private isObserved;
    private getObservedValue;
}
export declare class Potential {
    entries: PotentialEntry[];
    constructor();
    addEntry(entry: PotentialEntry): void;
    getMatchingEntries(entry: PotentialEntry): PotentialEntry[];
    toString(): string;
}
export declare class PotentialEntry {
    entries: Map<number, string>;
    value: number;
    constructor();
    add(id: number, value: string): PotentialEntry;
    matches(that: PotentialEntry): boolean;
    toString(): string;
    duplicate(): PotentialEntry;
}
export declare class IdUtil {
    static hashOfStr(s: string): number;
    static hashOfArr(arr: string[]): number;
}
export declare class PotentialUtil {
    static passSingleMessage(jointree: JoinTree, x: Clique, s: SepSet, y: Clique): void;
    static marginalizeFor(joinTree: JoinTree, clique: Clique, nodes: BbnNode[]): Potential;
    static normalize(potential: Potential): Potential;
    static divide(numerator: Potential, denominator: Potential): Potential;
    static multiply(bigger: Potential, smaller: Potential): void;
    static getPotential(node: BbnNode, parents: BbnNode[]): Potential;
    static getPotentialFromNodes(nodes: BbnNode[]): Potential;
    private static isZero;
    private static getCartesianProduct;
    private static merge;
}
export declare class BbnUtil {
    static getHuangGraph(): Bbn;
}
export declare class CompareUtil {
    static intCompare(x: number, y: number): number;
    static strCompare(x: string, y: string): number;
}
