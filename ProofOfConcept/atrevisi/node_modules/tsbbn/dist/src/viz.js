"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const d3 = require("d3");
const OUT_LEFT = 1, OUT_TOP = 2, OUT_RIGHT = 4, OUT_BOTTOM = 8;
const MAX_NODE_NAME_LENGTH = 15;
const MAX_VALUE_LENGTH = 5;
const MAX_PCT_VALUE = 6;
const DEFAULT_PADDING = '\u00A0';
class VGraph {
    constructor() {
        this.nodes = new Map();
        this.edges = new Map();
    }
    getNodes() {
        return Array.from(this.nodes.values());
    }
    getEdges() {
        return Array.from(this.edges.values());
    }
    addNode(node) {
        this.nodes.set(node.id, node);
        return this;
    }
    addEdge(edge) {
        this.edges.set(edge.getId(), edge);
        return this;
    }
    getNode(id) {
        return this.nodes.get(id);
    }
    getPath(id1, id2) {
        return this.getNode(id1).getPath(this.getNode(id2));
    }
}
exports.VGraph = VGraph;
class VEdge {
    constructor(parent, child) {
        this.parent = parent;
        this.child = child;
        this.points = [];
    }
    getId() {
        return Util.hashOfStr(this.toString());
    }
    toString() {
        return this.parent.label + '->' + this.child.label;
    }
}
exports.VEdge = VEdge;
class VNode {
    constructor(id, label, values, probs) {
        this.id = id;
        this.label = label;
        this.values = values;
        this.probs = probs;
        this.width = 150;
        this.probs = this.normalizeProbs(this.probs);
        this.height = values.length * 15 + 20;
        this.point = new VPoint(Math.random(), Math.random());
    }
    updatePoint(point) {
        this.point.x = point.x;
        this.point.y = point.y;
    }
    getRefId() {
        return this.label;
    }
    getTranslation() {
        return 'translate(' + this.point.x + ',' + this.point.y + ')';
    }
    getMid() {
        let dx = this.width / 2.0 + this.point.x;
        let dy = this.height / 2.0 + this.point.y;
        return new VPoint(dx, dy);
    }
    normalizeProbs(probs) {
        let sum = probs.reduce((a, b) => a + b);
        return probs.map(p => p / sum);
    }
    getPath(that) {
        let theta = that.point.getTheta(this.point);
        let p1 = this.getPoint(theta);
        let p2 = that.getPoint(theta + Math.PI);
        let error = p1.error || p2.error ? true : false;
        let path = new VPath(p1, p2);
        path.error = error;
        return path;
    }
    toString() {
        return this.id + '|' +
            this.label + '|' +
            this.values.join(',') + '|' +
            this.probs.join(',') + '|' +
            this.point.toString();
    }
    getPoint(theta) {
        let c = this.getMid();
        let cx = c.x;
        let cy = c.y;
        let w = this.width / 2.0;
        let h = this.height / 2.0;
        let d = this.getDistance(new VPoint(cx, cy), new VPoint(cx + w, cy + h));
        let x = cx + d * Math.cos(theta);
        let y = cy + d * Math.sin(theta);
        let ocode = this.getOutCode(new VPoint(x, y));
        let px = 0;
        let py = 0;
        let error = false;
        switch (ocode) {
            case OUT_TOP:
                px = cx - h * ((x - cx) / (y - cy));
                py = cy - h;
                break;
            case OUT_LEFT:
                px = cx - w;
                py = cy - w * ((y - cy) / (x - cx));
                break;
            case OUT_BOTTOM:
                px = cx + h * ((x - cx) / (y - cy));
                py = cy + h;
                break;
            case OUT_RIGHT:
                px = cx + w;
                py = cy + w * ((y - cy) / (x - cx));
                break;
            default:
                error = true;
        }
        let p = new VPoint(px, py);
        p.error = error;
        return p;
    }
    getDistance(p1, p2) {
        let x = p1.x - p2.x;
        let y = p1.y - p2.y;
        let d = Math.sqrt((x * x) + (y * y));
        return d;
    }
    getOutCode(point) {
        let out = 0;
        if (this.width <= 0) {
            out |= OUT_LEFT | OUT_RIGHT;
        }
        else if (point.x < this.point.x) {
            out |= OUT_LEFT;
        }
        else if (point.x > this.point.x + this.width) {
            out |= OUT_RIGHT;
        }
        if (this.height <= 0) {
            out |= OUT_TOP | OUT_BOTTOM;
        }
        else if (point.y < this.point.y) {
            out |= OUT_TOP;
        }
        else if (point.y > this.point.y + this.height) {
            out |= OUT_BOTTOM;
        }
        return out;
    }
}
exports.VNode = VNode;
class VPoint {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.error = false;
    }
    toString() {
        return '(' + this.x + ',' + this.y + ')';
    }
    getTheta(that) {
        return Math.atan2(this.y - that.y, this.x - that.x);
    }
}
exports.VPoint = VPoint;
class VPath {
    constructor(p1, p2) {
        this.p1 = p1;
        this.p2 = p2;
        this.error = false;
    }
    toString() {
        return this.p1.toString() + ' to ' + this.p2.toString();
    }
}
exports.VPath = VPath;
class Util {
    static hashOfStr(s) {
        let hash = 0;
        if (s.length === 0) {
            return hash;
        }
        for (let i = 0, len = s.length; i < len; i++) {
            let chr = s.charCodeAt(i);
            hash = ((hash << 5) - hash) + chr;
            hash |= 0; // Convert to 32bit integer
        }
        return hash;
    }
    static hashOfArr(arr) {
        return this.hashOfStr(arr.sort().join('-'));
    }
}
exports.Util = Util;
class NoOpInferenceEngine {
    constructor(graph) {
        this.graph = graph;
    }
    getGraph() {
        return this.graph;
    }
    updateEvidence(id, value) {
    }
    getProbs(id) {
        return this.graph.getNode(id).probs;
    }
}
exports.NoOpInferenceEngine = NoOpInferenceEngine;
class RenderOptions {
    constructor(id, width, height) {
        this.id = id;
        this.width = width;
        this.height = height;
    }
}
exports.RenderOptions = RenderOptions;
class GraphRenderer {
    constructor(engine, options) {
        this.engine = engine;
        this.options = options;
        this.graph = this.engine.getGraph();
    }
    draw() {
        this.initSvg();
        this.layoutGraph();
        this.drawEdges();
        this.drawNodes();
    }
    initSvg() {
        d3.select(this.options.id)
            .attr({
            width: this.options.width,
            height: this.options.height
        })
            .append('defs')
            .append('marker')
            .attr({
            id: 'arrow',
            markerWidth: 10,
            markerHeight: 10,
            refX: 5,
            refY: 3,
            orient: 'auto',
            markerUnits: 'strokeWidth'
        })
            .append('path')
            .attr({
            d: 'M0,0 L0,6, L5,3 z',
            fill: '#f00',
            class: 'edge-head'
        });
    }
    getDagreGraph() {
        let g = new dagre.graphlib.Graph();
        g.setGraph({});
        g.setDefaultEdgeLabel(() => {
            return {};
        });
        this.graph.getNodes()
            .forEach(n => {
            g.setNode(n.getRefId(), {
                label: n.getRefId(),
                width: n.width,
                height: n.height
            });
        });
        this.graph.getEdges()
            .forEach(e => {
            g.setEdge(e.parent.getRefId(), e.child.getRefId());
        });
        return g;
    }
    layoutGraph() {
        let g = this.getDagreGraph();
        dagre.layout(g);
        this.graph.getNodes()
            .forEach(n => {
            let dagreNode = g.node(n.getRefId());
            if (dagreNode) {
                n.updatePoint(new VPoint(dagreNode.x, dagreNode.y));
            }
        });
        this.graph.getEdges()
            .forEach(e => {
            let dagreEdge = g.edge({ v: e.parent.getRefId(), w: e.child.getRefId() });
            if (dagreEdge) {
                e.points = Array.from(dagreEdge.points)
                    .map(point => {
                    let p = point;
                    return new VPoint(p.x, p.y);
                });
            }
        });
    }
    drawEdges() {
        let graph = this.graph;
        let edges = d3.select(this.options.id)
            .selectAll('line')
            .data(graph.getEdges())
            .enter()
            .append('line')
            .each(function (d) {
            let path = graph.getPath(d.parent.id, d.child.id);
            d3.select(this).attr({
                'data-parent': d.parent.getRefId(),
                'data-child': d.child.getRefId(),
                x1: path.p1.x,
                y1: path.p1.y,
                x2: path.p2.x,
                y2: path.p2.y,
                style: 'stroke:rgb(255,0,0);stroke-width:2',
                class: 'edge-line',
                'marker-end': 'url(#arrow)'
            });
        });
    }
    drawNodes() {
        let engine = this.engine;
        let graph = this.graph;
        let formatNodeName = this.formatNodeName;
        let formatPct = this.formatPct;
        let formatValue = this.formatValue;
        let leftPad = this.leftPad;
        let rightPad = this.rightPad;
        // set the node group
        let nodes = d3.select(this.options.id)
            .selectAll('g')
            .data(graph.getNodes())
            .enter()
            .append('g')
            .attr({
            id: function (d) {
                return d.getRefId();
            },
            transform: function (d) {
                return d.getTranslation();
            },
            class: 'node-group'
        })
            .on('mousedown', function (d) {
            d3.selectAll('g.node-group').sort((a, b) => {
                if (a.id !== d.id) {
                    return -1;
                }
                else {
                    return 1;
                }
            });
        });
        // draw the node rectangle
        nodes.append('rect')
            .attr({
            x: 0,
            y: 0,
            class: 'node-shape',
            style: 'stroke:#000000; fill:none;',
            width: function (d) {
                return d.width;
            },
            height: function (d) {
                return d.height;
            },
            'pointer-events': 'visible',
            'data-node': function (d) {
                return d.getRefId();
            }
        });
        // draw the node's name/label
        nodes.append('text')
            .attr({
            x: function (d) {
                return d.width / 2;
            },
            y: 15,
            fill: 'black',
            class: 'node-name',
            'font-family': 'monospace',
            'font-size': 15
        })
            .text(function (d) {
            return formatNodeName(d.label);
        })
            .style('text-anchor', 'middle');
        // draw the node's value labels
        nodes.each(function (d) {
            let y = 30;
            d.values.forEach(value => {
                d3.select(this)
                    .append('text')
                    .attr({
                    x: 2,
                    y: y,
                    class: 'node-value',
                    'font-family': 'monospace',
                    'data-node': function (d) {
                        return d.getRefId();
                    },
                    'data-value': function (d) {
                        return value;
                    }
                })
                    .on('click', function (e) {
                    let node = e;
                    let h = this;
                    let v = h.attributes['data-value'].value;
                    engine.updateEvidence(node.id, v);
                    graph.getNodes().forEach(node => node.probs = engine.getProbs(node.id));
                    graph.getNodes().forEach(node => {
                        node.values.forEach((value, j) => {
                            // update belief bars
                            let selector = 'rect[data-node="' + node.getRefId() + '"][data-value="' + value + '"]';
                            d3.select(selector).attr({ width: node.probs[j] * 100 });
                            // update probability texts
                            selector = 'text[data-node="' + node.getRefId() + '"][data-pvalue="' + value + '"]';
                            d3.select(selector).text(formatPct(node.probs[j], leftPad));
                        });
                    });
                })
                    .text(function (d) {
                    return formatValue(value, leftPad);
                });
                y += 15;
            });
        });
        // draw the node's percentage text
        nodes.each(function (d) {
            let y = 30;
            for (let i = 0; i < d.probs.length; i++) {
                d3.select(this)
                    .append('text')
                    .attr({
                    x: 2 + d.width,
                    y: y,
                    'font-family': 'monospace',
                    class: 'node-pct',
                    'data-node': function (d) {
                        return d.getRefId();
                    },
                    'data-pvalue': function (d) {
                        return d.values[i];
                    }
                })
                    .text(function (d) {
                    return formatPct(d.probs[i], leftPad);
                });
                y += 15;
            }
        });
        // draw the node's belief bars
        nodes.each(function (d) {
            let y = 20;
            d.probs.forEach((prob, index) => {
                d3.select(this)
                    .append('rect')
                    .attr({
                    x: 50,
                    y: y,
                    width: prob * 100,
                    height: 10,
                    class: 'node-bar',
                    'data-node': function (d) {
                        return d.getRefId();
                    },
                    'data-value': function (d) {
                        return d.values[index];
                    }
                });
                y += 15;
            });
        });
        // draw the node's interquartile lines
        nodes.each(function (d) {
            let y1 = 20;
            let y2 = d.height - 5;
            let width = d.width - 50;
            let xInc = width / 4.0;
            let x = 50 + xInc;
            for (let i = 0; i < 3; i++) {
                d3.select(this)
                    .append('line')
                    .attr({
                    x1: x,
                    y1: y1,
                    x2: x,
                    y2: y2,
                    class: 'node-iqline',
                    'stroke-dasharray': '5, 1',
                    style: 'stroke:black; stroke-width:1px',
                });
                x += xInc;
            }
        });
        // set the dragging behavior
        let drag = d3.behavior.drag()
            .origin((d, i) => {
            let node = d;
            return node.point;
        })
            .on('dragstart', (d, i) => {
            let e = d3.event;
            e.sourceEvent.stopPropagation();
        })
            .on('drag', (d, i) => {
            let event = d3.event;
            let d3Event = d3.event;
            let mouseEvent = d3Event.sourceEvent;
            let node = d;
            node.point.x = event.x;
            node.point.y = event.y;
            let id = 'g#' + node.getRefId();
            d3.select(id).attr({
                transform: node.getTranslation()
            });
            let arcs = 'line[data-parent=' + node.getRefId() + ']';
            d3.selectAll(arcs)
                .each(function (d) {
                let edge = d;
                let path = graph.getPath(edge.parent.id, edge.child.id);
                d3.select(this).attr({
                    x1: path.p1.x,
                    y1: path.p1.y,
                    x2: path.p2.x,
                    y2: path.p2.y
                });
            });
            arcs = 'line[data-child=' + node.getRefId() + ']';
            d3.selectAll(arcs)
                .each(function (d) {
                let edge = d;
                let path = graph.getPath(edge.parent.id, edge.child.id);
                d3.select(this).attr({
                    x1: path.p1.x,
                    y1: path.p1.y,
                    x2: path.p2.x,
                    y2: path.p2.y
                });
            });
        });
        nodes.call(drag);
    }
    leftPad(pad, threhold, str) {
        let ostr = str;
        if (ostr.length < threhold) {
            while (ostr.length < threhold) {
                ostr = pad + ostr;
            }
            return ostr;
        }
        return ostr;
    }
    rightPad(pad, threhold, str) {
        let ostr = str;
        if (ostr.length < threhold) {
            while (ostr.length < threhold) {
                ostr += pad;
            }
            return ostr;
        }
        return ostr;
    }
    formatNodeName(v) {
        return v.length > MAX_NODE_NAME_LENGTH ? v.substr(0, MAX_NODE_NAME_LENGTH) : v;
    }
    formatValue(v, padding) {
        let value = v.length > MAX_VALUE_LENGTH ? v.substr(0, MAX_VALUE_LENGTH) : v;
        return padding(DEFAULT_PADDING, MAX_VALUE_LENGTH, value);
    }
    formatPct(p, padding) {
        return padding(DEFAULT_PADDING, MAX_PCT_VALUE, (p * 100).toFixed(2));
    }
}
exports.GraphRenderer = GraphRenderer;

//# sourceMappingURL=viz.js.map
