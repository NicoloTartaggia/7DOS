"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class Variable {
    constructor(id, name, _values) {
        this.id = id;
        this.name = name;
        this._values = _values;
        this.values = [..._values];
    }
}
exports.Variable = Variable;
class BGraph {
    constructor() {
        this.nodes = new Map();
        this.edges = new Map();
    }
    getNeighbors(id) {
        let keys = Array.from(this.edges.keys());
        let neighbors1 = keys.filter(key => this.edges.get(key).has(id));
        let neighbors2 = this.edges.has(id) ? Array.from(this.edges.get(id).values()) : [];
        let neighbors = neighbors1.concat(neighbors2);
        return new Set(neighbors);
    }
    getNode(id) {
        return this.nodes.get(id);
    }
    getNodes() {
        return Array.from(this.nodes.keys()).map(id => this.nodes.get(id));
    }
    getEdges() {
        let keys = Array.from(this.edges.keys());
        let stream = keys.map(lhsId => {
            let edges = Array.from(this.edges.get(lhsId))
                .map(rhsId => {
                let edgeType = EdgeType.UNDIRECTED;
                let leftId = lhsId;
                let rightId = rhsId;
                if (!this.edges.get(rhsId).has(lhsId)) {
                    edgeType = EdgeType.DIRECTED;
                }
                else {
                    leftId = Math.min(lhsId, rhsId);
                    rightId = leftId === lhsId ? rhsId : lhsId;
                }
                return new BEdge(new BNode(leftId), new BNode(rightId), edgeType);
            });
            return edges;
        });
        return this.removeDuplicates(this.flatten(stream));
    }
    addNode(node) {
        if (!this.nodes.has(node.id)) {
            this.nodes.set(node.id, node);
        }
        if (!this.edges.has(node.id)) {
            this.edges.set(node.id, new Set());
        }
        return this;
    }
    addEdge(edge) {
        let lhs = edge.lhs;
        let rhs = edge.rhs;
        this.addNode(lhs);
        this.addNode(rhs);
        if (this.shouldAdd(edge)) {
            let left = lhs.id;
            let right = rhs.id;
            if (EdgeType.UNDIRECTED === edge.type) {
                this.edges.get(left).add(right);
                this.edges.get(right).add(left);
            }
            else {
                this.edges.get(left).add(right);
            }
        }
        return this;
    }
    edgeExists(id1, id2) {
        if (this.edges.has(id1) && this.edges.get(id1).has(id2)) {
            return true;
        }
        if (this.edges.has(id2) && this.edges.get(id2).has(id1)) {
            return true;
        }
        return false;
    }
    removeNode(id) {
        this.nodes.delete(id);
        this.edges.delete(id);
        this.edges.forEach((v, k) => v.delete(id));
    }
    shouldAdd(edge) {
        let lhs = edge.lhs;
        let rhs = edge.rhs;
        if (lhs.id === rhs.id) {
            return false;
        }
        if (!this.edges.get(lhs.id).has(rhs.id)) {
            if (!this.edges.get(rhs.id).has(lhs.id)) {
                return true;
            }
        }
        return false;
    }
    flatten(edges) {
        let list = [];
        for (let i = 0; i < edges.length; i++) {
            for (let j = 0; j < edges[i].length; j++) {
                list.push(edges[i][j]);
            }
        }
        return list;
    }
    removeDuplicates(edges) {
        let map = new Map();
        let arr = [];
        edges.forEach(e => {
            let key = e.toString();
            if (!map.has(key)) {
                map.set(key, e);
                arr.push(e);
            }
        });
        return arr;
    }
}
exports.BGraph = BGraph;
class BNode {
    constructor(id) {
        this.id = id;
        this.metadata = new Map();
    }
    addMetadata(key, val) {
        this.metadata.set(key, val);
        return this;
    }
}
exports.BNode = BNode;
class BbnNode extends BNode {
    constructor(variable, probs = []) {
        super(variable.id);
        this.variable = variable;
        this.probs = probs;
    }
    getWeight() {
        return this.variable.values.length;
    }
    toString() {
        let s = this.variable.name + ' {';
        s += this.variable.values.join(',');
        s += '}';
        return s;
    }
}
exports.BbnNode = BbnNode;
class Clique extends BNode {
    constructor(nodes) {
        super(IdUtil.hashOfArr(nodes.map(n => '' + n.id)));
        this.nodes = nodes;
        this._marked = false;
    }
    isMarked() {
        return this._marked;
    }
    mark() {
        this._marked = true;
    }
    unmark() {
        this._marked = false;
    }
    nodesMinus(nodes) {
        let ids = this.nodes.map(n => n.id);
        return nodes.filter(n => ids.indexOf(n.id) === -1);
    }
    isSuperset(that) {
        let s1 = this.nodes.map(n => n.id);
        let s2 = new Set(that.nodes.map(n => n.id));
        let s3 = new Set(s1.filter(id => s2.has(id)));
        if (s2.size === s3.size) {
            // console.log(this.toString() + ' is superset of ' + that.toString());
            return true;
        }
        // console.log(this.toString() + ' is NOT superset of ' + that.toString());
        return false;
    }
    getWeight() {
        let weight = 1;
        this.nodes.forEach(n => {
            weight = weight * n.getWeight();
        });
        return weight;
    }
    contains(id) {
        let result = this.nodes.find(n => n.id === id);
        if (result) {
            return true;
        }
        return false;
    }
    getSepSet(that) {
        return new SepSet(this, that);
    }
    toString() {
        return '(' +
            this.nodes
                .map(n => n.variable.name)
                .sort((a, b) => CompareUtil.strCompare(a, b))
                .join('-') +
            ')';
    }
}
exports.Clique = Clique;
class SepSet extends Clique {
    constructor(left, right) {
        super([]);
        this.left = left;
        this.right = right;
        let set2 = new Set(left.nodes.map(n => n.id));
        let set1 = new Set(right.nodes.filter(n => set2.has(n.id)).map(n => n.id));
        this.nodes = left.nodes.filter(n => set1.has(n.id));
        this.id = IdUtil.hashOfArr(this.nodes.map(n => '' + n.id));
    }
    isEmpty() {
        return (this.nodes.length == 0) ? true : false;
    }
    getCost() {
        return this.left.getWeight() + this.right.getWeight();
    }
    getMass() {
        return this.nodes.length;
    }
    toString() {
        return '[' +
            this.nodes
                .map(n => n.variable.name)
                .sort((a, b) => CompareUtil.strCompare(a, b))
                .join('-') +
            ']';
    }
}
exports.SepSet = SepSet;
class BEdge {
    constructor(lhs, rhs, type = EdgeType.UNDIRECTED) {
        this.lhs = lhs;
        this.rhs = rhs;
        this.type = type;
    }
    toString() {
        let arrow = EdgeType.UNDIRECTED === this.type ? '--' : '->';
        let left = this.lhs.id;
        let right = this.rhs.id;
        if (EdgeType.UNDIRECTED === this.type) {
            left = Math.min(this.lhs.id, this.rhs.id);
            right = (this.lhs.id === left) ? this.rhs.id : this.lhs.id;
        }
        return left + arrow + right;
    }
}
exports.BEdge = BEdge;
class JtEdge extends BEdge {
    constructor(sepSet) {
        super(sepSet.left, sepSet.right, EdgeType.UNDIRECTED);
        this.sepSet = sepSet;
    }
    toString() {
        return this.sepSet.left.toString() + '--' +
            this.sepSet.toString() + '--' +
            this.sepSet.right.toString();
    }
}
exports.JtEdge = JtEdge;
var EdgeType;
(function (EdgeType) {
    EdgeType[EdgeType["UNDIRECTED"] = 1] = "UNDIRECTED";
    EdgeType[EdgeType["DIRECTED"] = 2] = "DIRECTED";
})(EdgeType = exports.EdgeType || (exports.EdgeType = {}));
class Dag extends BGraph {
    constructor() {
        super();
    }
    getParents(id) {
        let keys = Array.from(this.edges.keys());
        let parents = keys.filter(key => this.edges.get(key).has(id));
        return new Set(parents);
    }
    getChildren(id) {
        return this.edges.get(id);
    }
    edgeExists(id1, id2) {
        if (this.edges.has(id1) && this.edges.get(id1).has(id2)) {
            return true;
        }
        return false;
    }
    shouldAdd(edge) {
        let parent = edge.lhs;
        let child = edge.rhs;
        if (parent.id === child.id) {
            return false;
        }
        if (!this.edges.get(parent.id).has(child.id)) {
            if (!this.edges.get(child.id).has(parent.id)) {
                if (!(new DagPathDetector(this, child.id, parent.id)).exists()) {
                    return true;
                }
            }
        }
        return false;
    }
}
exports.Dag = Dag;
class Bbn extends Dag {
    shouldAdd(edge) {
        if (!(edge.lhs instanceof BbnNode) || !(edge.rhs instanceof BbnNode)) {
            return false;
        }
        return super.shouldAdd(edge);
    }
}
exports.Bbn = Bbn;
class DagPathDetector {
    constructor(graph, start, stop) {
        this.seen = new Set();
        this.graph = graph;
        this.start = start;
        this.stop = stop;
    }
    exists() {
        if (this.start === this.stop) {
            return true;
        }
        return this.find(this.start);
    }
    find(id) {
        let children = this.graph.getChildren(id);
        if (children.has(this.stop)) {
            return true;
        }
        else {
            this.seen.add(id);
            for (let child of children) {
                if (!this.seen.has(child) && this.find(child)) {
                    return true;
                }
            }
        }
        return false;
    }
}
class Pdag extends BGraph {
    getParents(id) {
        let parents = Array.from(this.edges.keys())
            .filter(key => this.edges.get(key).has(id) && !this.edges.get(id).has(key));
        return new Set(parents);
    }
    getOutNodes(id) {
        let parents = this.getParents(id);
        let subset = Array.from(this.getNeighbors(id)).filter(item => !parents.has(item));
        return new Set(subset);
    }
    shouldAdd(edge) {
        let parent = edge.lhs;
        let child = edge.rhs;
        if (parent.id === child.id) {
            return false;
        }
        if (!this.edges.get(parent.id).has(child.id)) {
            if (!this.edges.get(child.id).has(parent.id)) {
                if (!(new PdagPathDetector(this, child.id, parent.id)).exists()) {
                    return true;
                }
            }
        }
        return false;
    }
}
exports.Pdag = Pdag;
class PdagPathDetector {
    constructor(graph, start, stop) {
        this.seen = new Set();
        this.graph = graph;
        this.start = start;
        this.stop = stop;
    }
    exists() {
        if (this.start === this.stop) {
            return true;
        }
        return this.find(this.start);
    }
    find(id) {
        let outNodes = this.graph.getOutNodes(id);
        if (outNodes.has(this.stop)) {
            return true;
        }
        else {
            this.seen.add(id);
            for (let outNode of outNodes) {
                if (!this.seen.has(outNode)) {
                    if (this.find(outNode)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
}
class Ug extends BGraph {
    constructor() {
        super();
    }
}
exports.Ug = Ug;
class JoinTree extends Ug {
    constructor() {
        super();
        this.potentials = new Map();
        this.evidences = new Map();
    }
    getBbnPotential(node) {
        let clique = node.metadata.get('parent.clique');
        return PotentialUtil.normalize(PotentialUtil.marginalizeFor(this, clique, [node]));
    }
    unmarkCliques() {
        this.getCliques().forEach(clique => clique.unmark());
    }
    getBbnNodes() {
        let nodes = new Map();
        this.getCliques().forEach(clique => {
            clique.nodes.forEach(node => nodes.set(node.id, node));
        });
        let bbnNodes = [];
        nodes.forEach((v, k) => bbnNodes.push(v));
        return bbnNodes;
    }
    getBbnNode(id) {
        let bbnNodes = this.getBbnNodes();
        for (let i = 0; i < bbnNodes.length; i++) {
            if (id === bbnNodes[i].id) {
                return bbnNodes[i];
            }
        }
        return new BbnNode(new Variable(-1, '_dummy_', new Set()));
    }
    getBbnNodeByName(name) {
        return this.getBbnNodes().filter(n => n.variable.name === name)[0];
    }
    findCliquesWithNodeAndParents(id) {
        return this.getCliques()
            .filter(clique => {
            if (!(clique.contains(id))) {
                return false;
            }
            let bbnNode = this.getBbnNode(id);
            if (bbnNode.metadata.has('parents')) {
                let parents = bbnNode.metadata.get('parents');
                for (let i = 0; i < parents.length; i++) {
                    let parent = parents[i];
                    if (!(clique.contains(parent.id))) {
                        return false;
                    }
                }
            }
            return true;
        });
    }
    addPotential(clique, potential) {
        this.potentials.set(clique.id, potential);
        return this;
    }
    getCliques() {
        return this.getNodes()
            .filter(n => !(n instanceof SepSet))
            .map(n => n);
    }
    getSepSets() {
        return this.getNodes()
            .filter(n => (n instanceof SepSet))
            .map(n => n);
    }
    addEdge(edge) {
        if (!(edge instanceof JtEdge)) {
            return this;
        }
        let jtEdge = edge;
        let sepSet = jtEdge.sepSet;
        let lhs = jtEdge.lhs;
        let rhs = jtEdge.rhs;
        if (this.shouldAdd(edge)) {
            this.addNode(sepSet);
            this.addNode(lhs);
            this.addNode(rhs);
            this.edges.get(lhs.id).add(sepSet.id);
            this.edges.get(sepSet.id).add(lhs.id);
            this.edges.get(rhs.id).add(sepSet.id);
            this.edges.get(sepSet.id).add(rhs.id);
        }
        return this;
    }
    setListener(listener) {
        this.listener = listener;
    }
    getEvidence(node, value) {
        if (!this.evidences.has(node.id)) {
            this.evidences.set(node.id, new Map());
        }
        if (!this.evidences.get(node.id).has(value)) {
            let potentialEntry = new PotentialEntry();
            potentialEntry.add(node.id, value);
            potentialEntry.value = 1.0;
            let potential = new Potential();
            potential.addEntry(potentialEntry);
            this.evidences.get(node.id).set(value, potential);
        }
        return this.evidences.get(node.id).get(value);
    }
    unobserve(nodes) {
        let evidences = nodes.map(n => this.getUnobservedEvidence(n));
        this.updateEvidences(evidences);
        return this;
    }
    unobserveAll() {
        this.unobserve(this.getBbnNodes());
        return this;
    }
    updateEvidences(evidences) {
        evidences.forEach(e => e.validate());
        let change = this.getChangeType(evidences);
        evidences.forEach(evidence => {
            let node = evidence.node;
            let potentials = this.evidences.get(node.id);
            evidence.values.forEach((v, k) => {
                let potential = potentials.get(k);
                potential.entries[0].value = v;
            });
        });
        this.notifyListener(change);
        return this;
    }
    setObservation(evidence) {
        // only deal with observation types in this method
        if (EvidenceType.OBSERVATION !== evidence.type) {
            // console.log('evidence not observation type returning');
            return this;
        }
        // check to see if previous evidence was also observation
        // evidence that is observation type always has only one value that is 1
        let potentials = this.evidences.get(evidence.node.id);
        let pvalues = Array.from(potentials.keys())
            .filter(v => {
            let potential = potentials.get(v);
            let entry = potential.entries[0];
            let p = entry.value;
            if (p === 1.0) {
                return true;
            }
            return false;
        });
        let cvalues = Array.from(evidence.values.keys())
            .filter(v => 1.0 === evidence.values.get(v));
        if (1 === pvalues.length) {
            // previous evidence was of type observation
            // both current and previous evidences are observation type
            // console.log('both previous and current evidences are of type observation');
            let lastValue = pvalues[0];
            let currValue = cvalues[0];
            if (lastValue === currValue) {
                // if the last value is equal to the current value, unobserve it
                // console.log(lastValue + ' equals ' + currValue + ' so will unobserve');
                this.unobserve([evidence.node]);
            }
            else {
                // console.log(lastValue + ' NOT equals ' + currValue + ' so will update evidence');
                this.updateEvidences([evidence]);
            }
        }
        else {
            // console.log('number previous values === 1 was ' + pvalues.length + ' so will update evidence');
            this.updateEvidences([evidence]);
        }
        return this;
    }
    shouldAdd(edge) {
        let jtEdge = edge;
        let sepSet = jtEdge.sepSet;
        let lhs = jtEdge.lhs;
        let rhs = jtEdge.rhs;
        if (lhs.id === rhs.id) {
            // console.log('false: ' + jtEdge.toString());
            return false;
        }
        if (!(new JoinTreePathDetector(this, lhs.id, rhs.id)).exists()) {
            // console.log('true: ' +  jtEdge.toString());
            return true;
        }
        // console.log('false: ' + jtEdge.toString());
        return false;
    }
    getChangeType(evidences) {
        let changes = evidences.map(evidence => {
            let node = evidence.node;
            let potentials = this.evidences.get(node.id);
            let change = evidence.compare(potentials);
            return change;
        });
        let count = changes.filter(c => ChangeType.RETRACTION === c).length;
        if (count > 0) {
            return ChangeType.RETRACTION;
        }
        count = changes.filter(c => ChangeType.UPDATE === c).length;
        if (count > 0) {
            return ChangeType.UPDATE;
        }
        return ChangeType.NONE;
    }
    getUnobservedEvidence(node) {
        let evidence = new Evidence(node, EvidenceType.UNOBSERVE);
        node.variable.values.forEach(v => evidence.addValue(v, 1.0));
        return evidence;
    }
    notifyListener(change) {
        if (this.listener) {
            if (ChangeType.RETRACTION === change) {
                this.listener.evidenceRetracted(this);
            }
            else if (ChangeType.UPDATE === change) {
                this.listener.evidenceUpdated(this);
            }
        }
    }
}
exports.JoinTree = JoinTree;
class JoinTreePathDetector {
    constructor(graph, start, stop) {
        this.seen = new Set();
        this.graph = graph;
        this.start = start;
        this.stop = stop;
    }
    exists() {
        if (this.start === this.stop) {
            return true;
        }
        return this.find(this.start);
    }
    find(id) {
        let neighbors = this.graph.getNeighbors(id);
        if (neighbors.has(this.stop)) {
            return true;
        }
        else {
            this.seen.add(id);
            for (let neighbor of neighbors) {
                if (!this.seen.has(neighbor)) {
                    if (this.find(neighbor)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
}
var EvidenceType;
(function (EvidenceType) {
    EvidenceType[EvidenceType["VIRTUAL"] = 1] = "VIRTUAL";
    EvidenceType[EvidenceType["FINDING"] = 2] = "FINDING";
    EvidenceType[EvidenceType["OBSERVATION"] = 3] = "OBSERVATION";
    EvidenceType[EvidenceType["UNOBSERVE"] = 4] = "UNOBSERVE";
})(EvidenceType = exports.EvidenceType || (exports.EvidenceType = {}));
var ChangeType;
(function (ChangeType) {
    ChangeType[ChangeType["NONE"] = 1] = "NONE";
    ChangeType[ChangeType["UPDATE"] = 2] = "UPDATE";
    ChangeType[ChangeType["RETRACTION"] = 3] = "RETRACTION";
})(ChangeType = exports.ChangeType || (exports.ChangeType = {}));
class EvidenceBuilder {
    constructor() {
        this.values = new Map();
        this.type = EvidenceType.OBSERVATION;
    }
    withNode(node) {
        this.node = node;
        return this;
    }
    withType(type) {
        this.type = type;
        return this;
    }
    withEvidence(val, likelihood) {
        this.values.set(val, likelihood);
        return this;
    }
    build() {
        let evidence = new Evidence(this.node, this.type);
        this.values.forEach((v, k) => evidence.values.set(k, v));
        return evidence;
    }
}
exports.EvidenceBuilder = EvidenceBuilder;
class Evidence {
    constructor(node, type) {
        this.node = node;
        this.type = type;
        this.values = new Map();
    }
    addValue(value, likelihood) {
        this.values.set(value, likelihood);
        return this;
    }
    compare(potentials) {
        let that = this.convert(potentials);
        let unobserveThat = this.isUnobserved(that);
        let unobserveThis = this.isUnobserved(this.values);
        if (unobserveThat && unobserveThis) {
            return ChangeType.NONE;
        }
        let observeThat = this.isObserved(that);
        let observeThis = this.isObserved(this.values);
        if (observeThat && observeThis) {
            let s1 = this.getObservedValue(that);
            let s2 = this.getObservedValue(this.values);
            if (s1 === s2) {
                return ChangeType.NONE;
            }
            else {
                return ChangeType.RETRACTION;
            }
        }
        return ChangeType.RETRACTION;
    }
    validate() {
        this.node.variable.values.forEach(value => {
            if (!this.values.has(value)) {
                this.values.set(value, 0.0);
            }
        });
        if (EvidenceType.VIRTUAL === this.type) {
            let sum = this.node.variable.values
                .map(value => this.values.get(value))
                .reduce((a, b) => a + b);
            this.node.variable.values.forEach(value => {
                let d = this.values.get(value) / sum;
                this.values.set(value, d);
            });
        }
        else if (EvidenceType.FINDING === this.type) {
            this.node.variable.values.forEach(value => {
                let d = this.values.get(value) > 0.0 ? 1.0 : 0.0;
                this.values.set(value, d);
            });
            let count = this.node.variable.values
                .map(value => this.values.get(value))
                .reduce((a, b) => a + b);
            if (0 === count) {
                this.node.variable.values.forEach(value => this.values.set(value, 1.0));
            }
        }
        else if (EvidenceType.OBSERVATION === this.type) {
            let keys = Array.from(this.values.keys())
                .sort((a, b) => -1 * CompareUtil.intCompare(this.values.get(a), this.values.get(b)));
            let key = keys[0];
            this.node.variable.values.forEach(value => {
                if (key === value) {
                    this.values.set(value, 1.0);
                }
                else {
                    this.values.set(value, 0.0);
                }
            });
        }
        else if (EvidenceType.UNOBSERVE === this.type) {
            this.node.variable.values.forEach(value => this.values.set(value, 1.0));
        }
    }
    convert(map) {
        let m = new Map();
        map.forEach((v, k) => {
            let likelihood = v.entries[0].value;
            m.set(k, likelihood);
        });
        return m;
    }
    isUnobserved(values) {
        let counts = 0;
        values.forEach((v, k) => counts += v);
        return (counts === values.size);
    }
    isObserved(values) {
        let countOne = 0;
        let countZero = 0;
        values.forEach((v, k) => {
            if (1.0 === v) {
                countOne++;
            }
            else if (0.0 === v) {
                countZero++;
            }
        });
        return (1 === countOne && values.size - 1 === countZero);
    }
    getObservedValue(values) {
        let strs = Array.from(values.keys())
            .filter(k => (1.0 === values.get(k)));
        return strs[0];
    }
}
exports.Evidence = Evidence;
class Potential {
    constructor() {
        this.entries = [];
    }
    addEntry(entry) {
        this.entries.push(entry);
    }
    getMatchingEntries(entry) {
        return this.entries.filter(e => e.matches(entry));
    }
    toString() {
        let s = '';
        this.entries.forEach(entry => s += entry.toString() + '\n');
        return s.substr(0, s.length - 1);
    }
}
exports.Potential = Potential;
class PotentialEntry {
    constructor() {
        this.entries = new Map();
        this.value = 1.0;
    }
    add(id, value) {
        if (!this.entries.has(id)) {
            this.entries.set(id, value);
        }
        return this;
    }
    matches(that) {
        for (let key of that.entries.keys()) {
            if (!this.entries.has(key) || !(this.entries.get(key) === that.entries.get(key))) {
                return false;
            }
        }
        return true;
    }
    toString() {
        let s = '';
        this.entries.forEach((v, k) => {
            s += k + '=' + v + ',';
        });
        s += this.value;
        return s;
    }
    duplicate() {
        let entry = new PotentialEntry();
        this.entries.forEach((v, k) => entry.add(k, v));
        entry.value = this.value;
        return entry;
    }
}
exports.PotentialEntry = PotentialEntry;
class IdUtil {
    static hashOfStr(s) {
        let hash = 0;
        if (s.length === 0) {
            return hash;
        }
        for (let i = 0, len = s.length; i < len; i++) {
            let chr = s.charCodeAt(i);
            hash = ((hash << 5) - hash) + chr;
            hash |= 0; // Convert to 32bit integer
        }
        return hash;
    }
    static hashOfArr(arr) {
        return this.hashOfStr(arr.sort().join('-'));
    }
}
exports.IdUtil = IdUtil;
class PotentialUtil {
    static passSingleMessage(jointree, x, s, y) {
        // console.log('passing message ' + x.toString() + ' -- ' + s.toString() + ' -- ' + y.toString());
        let oldSepSetPotential = jointree.potentials.get(s.id);
        let yPotential = jointree.potentials.get(y.id);
        let newSepSetPotential = this.marginalizeFor(jointree, x, s.nodes);
        jointree.addPotential(s, newSepSetPotential);
        this.multiply(yPotential, this.divide(newSepSetPotential, oldSepSetPotential));
    }
    static marginalizeFor(joinTree, clique, nodes) {
        let potential = this.getPotentialFromNodes(nodes);
        let cliquePotential = joinTree.potentials.get(clique.id);
        potential.entries.forEach(entry => {
            let matchedEntries = cliquePotential.getMatchingEntries(entry);
            let t = 0.0;
            matchedEntries.forEach(matchedEntry => t += matchedEntry.value);
            entry.value = t;
        });
        return potential;
    }
    static normalize(potential) {
        let sum = 0.0;
        potential.entries.forEach(entry => {
            sum += entry.value;
        });
        potential.entries.forEach(entry => {
            let d = entry.value / sum;
            entry.value = d;
        });
        return potential;
    }
    static divide(numerator, denominator) {
        let potential = new Potential();
        numerator.entries.forEach(entry => {
            let entries = denominator.entries;
            if (entries.length > 0) {
                let e = entries[0];
                let d = (this.isZero(entry.value) || this.isZero(e.value)) ? 0.0 : entry.value / e.value;
                let newEntry = entry.duplicate();
                newEntry.value = d;
                potential.addEntry(newEntry);
            }
        });
        return potential;
    }
    static multiply(bigger, smaller) {
        smaller.entries.forEach(entry => {
            let entries = bigger.getMatchingEntries(entry);
            entries.forEach(e => {
                let d = e.value * entry.value;
                e.value = d;
            });
        });
    }
    static getPotential(node, parents) {
        let potential = this.getPotentialFromNodes(this.merge(node, parents));
        let total = potential.entries.length;
        for (let i = 0; i < total; i++) {
            let prob = node.probs[i];
            potential.entries[i].value = prob;
        }
        return potential;
    }
    static getPotentialFromNodes(nodes) {
        let valueLists = nodes.map(n => n.variable.values);
        let cartesian = this.getCartesianProduct(valueLists);
        let potential = new Potential();
        cartesian.forEach(values => {
            let entry = new PotentialEntry();
            for (let i = 0; i < nodes.length; i++) {
                let value = values[i];
                let id = nodes[i].id;
                entry.add(id, value);
            }
            potential.addEntry(entry);
        });
        return potential;
    }
    static isZero(d) {
        return (0 === d);
    }
    static getCartesianProduct(lists) {
        let results = [];
        if (lists.length === 0) {
            return results;
        }
        else {
            let first = lists[0];
            let tail = lists.slice(0).splice(1);
            let remaining = this.getCartesianProduct(tail);
            first.forEach(condition => {
                if (remaining.length > 0) {
                    remaining.forEach(rlist => {
                        let result = [];
                        result.push(condition);
                        rlist.forEach(r => result.push(r));
                        results.push(result);
                    });
                }
                else {
                    let result = [];
                    result.push(condition);
                    results.push(result);
                }
            });
        }
        return results;
    }
    static merge(node, parents) {
        let nodes = [];
        parents.forEach(n => nodes.push(n));
        nodes.push(node);
        return nodes;
    }
}
exports.PotentialUtil = PotentialUtil;
class BbnUtil {
    static getHuangGraph() {
        let a = new BbnNode(new Variable(0, 'a', new Set(['on', 'off'])), [0.5, 0.5]);
        let b = new BbnNode(new Variable(1, 'b', new Set(['on', 'off'])), [0.5, 0.5, 0.4, 0.6]);
        let c = new BbnNode(new Variable(2, 'c', new Set(['on', 'off'])), [0.7, 0.3, 0.2, 0.8]);
        let d = new BbnNode(new Variable(3, 'd', new Set(['on', 'off'])), [0.9, 0.1, 0.5, 0.5]);
        let e = new BbnNode(new Variable(4, 'e', new Set(['on', 'off'])), [0.3, 0.7, 0.6, 0.4]);
        let f = new BbnNode(new Variable(5, 'f', new Set(['on', 'off'])), [0.01, 0.99, 0.01, 0.99, 0.01, 0.99, 0.99, 0.01]);
        let g = new BbnNode(new Variable(6, 'g', new Set(['on', 'off'])), [0.8, 0.2, 0.1, 0.9]);
        let h = new BbnNode(new Variable(7, 'h', new Set(['on', 'off'])), [0.05, 0.95, 0.95, 0.05, 0.95, 0.05, 0.95, 0.05]);
        let bbn = new Bbn()
            .addNode(a)
            .addNode(b)
            .addNode(c)
            .addNode(d)
            .addNode(e)
            .addNode(f)
            .addNode(g)
            .addNode(h)
            .addEdge(new BEdge(a, b, EdgeType.DIRECTED))
            .addEdge(new BEdge(a, c, EdgeType.DIRECTED))
            .addEdge(new BEdge(b, d, EdgeType.DIRECTED))
            .addEdge(new BEdge(c, e, EdgeType.DIRECTED))
            .addEdge(new BEdge(d, f, EdgeType.DIRECTED))
            .addEdge(new BEdge(e, f, EdgeType.DIRECTED))
            .addEdge(new BEdge(c, g, EdgeType.DIRECTED))
            .addEdge(new BEdge(e, h, EdgeType.DIRECTED))
            .addEdge(new BEdge(g, h, EdgeType.DIRECTED));
        return bbn;
    }
}
exports.BbnUtil = BbnUtil;
class CompareUtil {
    static intCompare(x, y) {
        return (x < y) ? -1 : ((x === y) ? 0 : 1);
    }
    static strCompare(x, y) {
        return x.localeCompare(y);
    }
}
exports.CompareUtil = CompareUtil;

//# sourceMappingURL=graph.js.map
