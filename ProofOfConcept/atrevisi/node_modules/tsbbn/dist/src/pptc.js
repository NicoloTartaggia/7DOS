"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const graph_1 = require("./graph");
class InferenceController {
    static apply(bbn) {
        PotentialInitializer.init(bbn);
        let ug = Moralizer.moralize(bbn);
        let cliques = Triangulator.triangulate(ug);
        let joinTree = Transformer.transform(cliques);
        Initializer.initialize(joinTree);
        Propagator.propagate(joinTree);
        joinTree.setListener(new InferenceController());
        return joinTree;
    }
    evidenceRetracted(jointree) {
        Initializer.initialize(jointree);
        Propagator.propagate(jointree);
    }
    evidenceUpdated(jointree) {
        Propagator.propagate(jointree);
    }
}
exports.InferenceController = InferenceController;
class Initializer {
    static initialize(joinTree) {
        joinTree.getCliques().forEach(clique => {
            let potential = graph_1.PotentialUtil.getPotentialFromNodes(clique.nodes);
            joinTree.addPotential(clique, potential);
        });
        joinTree.getSepSets().forEach(sepSet => {
            let potential = graph_1.PotentialUtil.getPotentialFromNodes(sepSet.nodes);
            joinTree.addPotential(sepSet, potential);
        });
        joinTree.getBbnNodes().forEach(node => {
            let clique = this.getClique(node, joinTree);
            // console.log(node.variable.name + ' mapped to clique ' + clique.toString());
            let p1 = joinTree.potentials.get(clique.id);
            let p2 = node.potential;
            // console.log(p1.toString());
            // console.log('>>>>');
            // console.log(p2.toString());
            // console.log('----');
            graph_1.PotentialUtil.multiply(p1, p2);
            // console.log(p1.toString());
            // console.log('****');
        });
        joinTree.getBbnNodes().forEach(node => {
            node.variable.values.forEach(value => {
                let clique = node.metadata.get('parent.clique');
                let cliquePotential = joinTree.potentials.get(clique.id);
                let nodePotential = joinTree.getEvidence(node, value);
                graph_1.PotentialUtil.multiply(cliquePotential, nodePotential);
                // console.log(clique.toString());
                // console.log(cliquePotential.toString());
            });
        });
        return joinTree;
    }
    static getClique(node, jointree) {
        let clique;
        if (!node.metadata.has('parent.clique')) {
            let cliques = jointree.findCliquesWithNodeAndParents(node.id)
                .sort((a, b) => graph_1.CompareUtil.intCompare(a.id, b.id));
            clique = cliques[0];
        }
        else {
            clique = node.metadata.get('parent.clique');
        }
        node.addMetadata('parent.clique', clique);
        return clique;
    }
}
exports.Initializer = Initializer;
class Moralizer {
    static moralize(dag) {
        let ug = new graph_1.Ug();
        dag.getNodes().forEach(node => ug.addNode(node));
        dag.getEdges().forEach(edge => ug.addEdge(new graph_1.BEdge(edge.lhs, edge.rhs)));
        dag.getNodes().forEach(node => {
            let parents = Array.from(dag.getParents(node.id));
            let size = parents.length;
            for (let i = 0; i < size; i++) {
                let pa1 = dag.getNode(parents[i]);
                for (let j = i + 1; j < size; j++) {
                    let pa2 = dag.getNode(parents[j]);
                    ug.addEdge(new graph_1.BEdge(pa1, pa2));
                }
            }
        });
        dag.getNodes().forEach(node => {
            let parents = Array.from(dag.getParents(node.id)).map(id => dag.getNode(id));
            node.addMetadata('parents', parents);
        });
        return ug;
    }
}
exports.Moralizer = Moralizer;
class PotentialInitializer {
    static init(bbn) {
        bbn.getNodes().forEach(node => {
            let bbnNode = node;
            let parents = Array.from(bbn.getParents(node.id)).map(id => bbn.getNode(id));
            bbnNode.potential = graph_1.PotentialUtil.getPotential(bbnNode, parents);
        });
    }
}
exports.PotentialInitializer = PotentialInitializer;
class Propagator {
    static propagate(joinTree) {
        let cliques = joinTree.getCliques().sort((a, b) => graph_1.CompareUtil.intCompare(a.id, b.id));
        let x = cliques[0];
        // console.log(x.toString());
        joinTree.unmarkCliques();
        this.collectEvidence(joinTree, x);
        joinTree.unmarkCliques();
        this.distributeEvidence(joinTree, x);
        return joinTree;
    }
    static collectEvidence(jointree, start) {
        let collector = new EvidenceCollector(jointree, start);
        collector.start();
    }
    static distributeEvidence(jointree, start) {
        let distributor = new EvidenceDistributor(jointree, start);
        distributor.start();
    }
}
exports.Propagator = Propagator;
class Transformer {
    static transform(cliques) {
        let jointree = new graph_1.JoinTree();
        cliques.forEach(c => jointree.addNode(c));
        let sepSets = this.getSepSets(cliques);
        sepSets.forEach(s => jointree.addEdge(new graph_1.JtEdge(s)));
        return jointree;
    }
    static getSepSets(cliques) {
        let sepSets = [];
        let size = cliques.length;
        for (let i = 0; i < size; i++) {
            for (let j = i + 1; j < size; j++) {
                const sepSet = new graph_1.SepSet(cliques[i], cliques[j]);
                if (!sepSet.isEmpty()) {
                    sepSets.push(sepSet);
                }
            }
        }
        return sepSets.sort((a, b) => {
            let result = -1 * graph_1.CompareUtil.intCompare(a.getMass(), b.getMass());
            if (0 === result) {
                result = graph_1.CompareUtil.intCompare(a.getCost(), b.getCost());
                if (0 === result) {
                    result = graph_1.CompareUtil.intCompare(a.id, b.id);
                }
            }
            return result;
        });
    }
}
exports.Transformer = Transformer;
class Triangulator {
    static triangulate(m) {
        let cliques = [];
        let mm = this.duplicate(m);
        while (mm.getNodes().length > 0) {
            let nodeClique = this.selectNode(mm);
            let clique = new graph_1.Clique(nodeClique.getBbnNodes());
            if (!this.isSubset(cliques, clique)) {
                cliques.push(clique);
            }
            mm.removeNode(nodeClique.node.id);
            nodeClique.edges.forEach(e => {
                m.addEdge(e);
                mm.addEdge(e);
            });
        }
        return cliques;
    }
    static duplicate(g) {
        let ug = new graph_1.Ug();
        g.getNodes().forEach(n => ug.addNode(n));
        g.getEdges().forEach(e => ug.addEdge(e));
        return ug;
    }
    static selectNode(m) {
        let cliques = m.getNodes()
            .map(node => {
            let weight = this.getWeight(node, m);
            let edges = this.getEdgesToAdd(node, m);
            let neighbors = Array.from(m.getNeighbors(node.id)).map(id => m.getNode(id));
            return new NodeClique(node, neighbors, weight, edges);
        })
            .sort((a, b) => {
            let result = graph_1.CompareUtil.intCompare(a.edges.length, b.edges.length);
            if (0 === result) {
                result = graph_1.CompareUtil.intCompare(a.weight, b.weight);
                if (0 === result) {
                    result = graph_1.CompareUtil.intCompare(a.node.id, b.node.id);
                }
            }
            return result;
        });
        return cliques[0];
    }
    static getWeight(n, m) {
        let weight = n.getWeight();
        Array.from(m.getNeighbors(n.id))
            .map(id => m.getNode(id))
            .forEach(neighbor => weight *= neighbor.getWeight());
        return weight;
    }
    static getEdgesToAdd(n, m) {
        let edges = [];
        let neighbors = Array.from(m.getNeighbors(n.id)).map(id => m.getNode(id));
        let size = neighbors.length;
        for (let i = 0; i < size; i++) {
            let ne1 = neighbors[i];
            for (let j = 0; j < size; j++) {
                let ne2 = neighbors[j];
                if (!m.edgeExists(ne1.id, ne2.id)) {
                    edges.push(new graph_1.BEdge(ne1, ne2));
                }
            }
        }
        return edges;
    }
    static isSubset(cliques, clique) {
        for (let i = 0; i < cliques.length; i++) {
            if (cliques[i].isSuperset(clique)) {
                return true;
            }
        }
        return false;
    }
}
exports.Triangulator = Triangulator;
class NodeClique {
    constructor(node, neighbors, weight, edges) {
        this.node = node;
        this.neighbors = neighbors;
        this.weight = weight;
        this.edges = edges;
    }
    getBbnNodes() {
        let nodes = this.neighbors.slice(0);
        nodes.push(this.node);
        return nodes.map(n => n);
    }
}
class EvidenceCollector {
    constructor(joinTree, startClique) {
        this.joinTree = joinTree;
        this.startClique = startClique;
    }
    start() {
        // console.log('STARTING EVIDENCE COLLECTION from ' + this.startClique.toString());
        this.startClique.mark();
        this.joinTree.getNeighbors(this.startClique.id).forEach(sepSetId => {
            let sepSet = this.joinTree.getNode(sepSetId);
            Array.from(this.joinTree.getNeighbors(sepSetId))
                .map(id => this.joinTree.getNode(id))
                .filter(clique => !clique.isMarked())
                .forEach(y => {
                this.walk(this.startClique, sepSet, y);
            });
        });
    }
    walk(x, s, y) {
        y.mark();
        Array.from(this.joinTree.getNeighbors(y.id))
            .map(id => this.joinTree.getNode(id))
            .forEach(sepSet => {
            Array.from(this.joinTree.getNeighbors(sepSet.id))
                .map(id => this.joinTree.getNode(id))
                .filter(clique => !clique.isMarked())
                .forEach(clique => this.walk(y, sepSet, clique));
        });
        graph_1.PotentialUtil.passSingleMessage(this.joinTree, y, s, x);
    }
}
exports.EvidenceCollector = EvidenceCollector;
class EvidenceDistributor {
    constructor(joinTree, startClique) {
        this.joinTree = joinTree;
        this.startClique = startClique;
    }
    start() {
        // console.log('STARTING EVIDENCE DISTRIBUTION from ' + this.startClique.toString());
        this.startClique.mark();
        this.joinTree.getNeighbors(this.startClique.id).forEach(sepSetId => {
            let sepSet = this.joinTree.getNode(sepSetId);
            Array.from(this.joinTree.getNeighbors(sepSetId))
                .map(id => this.joinTree.getNode(id))
                .filter(clique => !clique.isMarked())
                .forEach(y => {
                graph_1.PotentialUtil.passSingleMessage(this.joinTree, this.startClique, sepSet, y);
                this.walk(this.startClique, sepSet, y);
            });
        });
    }
    walk(x, s, y) {
        y.mark();
        Array.from(this.joinTree.getNeighbors(y.id))
            .map(id => this.joinTree.getNode(id))
            .forEach(sepSet => {
            Array.from(this.joinTree.getNeighbors(sepSet.id))
                .map(id => this.joinTree.getNode(id))
                .filter(clique => !clique.isMarked())
                .forEach(clique => {
                graph_1.PotentialUtil.passSingleMessage(this.joinTree, y, sepSet, clique);
                this.walk(y, sepSet, clique);
            });
        });
    }
}
exports.EvidenceDistributor = EvidenceDistributor;

//# sourceMappingURL=pptc.js.map
